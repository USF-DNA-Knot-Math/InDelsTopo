{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InDelsTopo","text":"<p>InDelsTopo is a Python package for studying the topological structure of sets of words,  especially when their primary source of variation arises from insertions and deletions.  </p> <p>It implements the Insertion Chain Complex introduced in  </p> <p>Natasha Jonoska, Francisco Martinez-Figueroa, and Masahico Saito, The Insertion Chain Complex: A Topological Approach to the Structure of Word Sets, 2025.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Insertion Chain Complex framework provides a topological structure on the relationships between words that differ by insertions and deletions. It was originally developed to model DNA sequence variation during double-strand break repair but can be applied to any setting where the structure of sets of words needs to be analyzed. </p> <p>InDelsTopo provides:</p> <ul> <li>Construction of Filtrations and Complexes over word sets  </li> <li>Tools to compute homology, Euler characteristic curves, and persistent homology </li> <li>Optional integration with SageMath </li> <li>Methods to analyze and visualize the topological structure of word sets </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install via pip:</p> <pre><code>pip install InDelsTopo\n</code></pre> <p>For full functionality (e.g., integer homology over \\(\\mathbb{Z}\\)), install SageMath and run your notebooks in a SageMath kernel.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from InDelsTopo import Filtration, filtration_plot\n\n# Create a filtration from a small set of words\nF = Filtration()\nF.compute_d_skeleton(['a', 'b', 'ab', '', 'ba'], [1,2,3,4,5])\n\n# Visualize the sublevel sets at different heights. \nF.get_graph(1)\nF.get_graph(2)\nF.get_graph(5)\n</code></pre>"},{"location":"#main-concepts","title":"Main Concepts","text":"Concept Description Block Represents a combinatorial element generated by insertions. Chain Linear combination of blocks with integer coefficients. Complex Collection of blocks and faces forming a topological structure. Filtration Sequence of nested complexes indexed by a height function. <p>For detailed examples, see the Jupyter Notebook Tutorial.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>Reference: API documentation.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use InDelsTopo in academic work, please cite:</p> <p>Jonoska, N., Martinez-Figueroa, F., &amp; Saito, M. The Insertion Chain Complex: A Topological Approach to the Structure of Word Sets. arXiv preprint arXiv:2509.12607, 2025.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions, pull requests, and feedback are welcome! Please open an issue on the GitHub repository.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This project was developed at the University of South Florida, in collaboration with Prof. Natasha Jonoska and Prof. Masahico Saito (University of South Florida), and insights from experimental data provided by Prof. Francesca Storici\u2019s lab (Georgia Tech).</p> <p>This package was built under auspices of the Southeast Center for Mathematics and Biology, an NSF-Simons Research Center for Mathematics of Complex Biological Systems, under National Science Foundation Grant No. DMS-1764406 and Simons Foundation Grant No. 594594 as well as NSF DMS-2054321, CCF-2107267, CCF-2505771 and the W.M. Keck Foundation.</p>"},{"location":"reference/","title":"Python package docs","text":"<p>InDelsTopo: A Python package to analyze topological properties of sets of words when their main source of variation are insertions and deletions, using the Insertion Chain Complex framework.</p>"},{"location":"reference/#InDelsTopo.__version__","title":"<code>__version__ = '0.1.0'</code>  <code>module-attribute</code>","text":""},{"location":"reference/#InDelsTopo.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>ChainBlockBase</code></p> <p>Represents a Block in the Insertion Chain Complex.</p> <p>A Block can be a valid block or \"0\" if the provided data corresponds to an invalid block. It has the formal expression x_0(1,a_1)x_1...(1,a_m)x_m, where the a_i are single symbols from an alphabet, and the x_i are words over that alphabet (including possibly the empty word). Internally, blocks are stored as a list of factors x_0, ..., x_k and a list of edge symbols a_1, ..., a_k, represented as SymPy expressions and symbols.</p> <p>Blocks can be initialized from a string expression or directly via x_factors and edges.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Number of edges (dimension) of the block.</p> <code>max_word</code> <code>SymPy expression</code> <p>Maximal word of the block.</p> <code>min_word</code> <code>SymPy expression</code> <p>Minimal word of the block.</p> <code>#</code> <code>_x_factors (list of SymPy expressions or int</code> <p>Factors of the block.</p> <code>#</code> <code>_edges (list of SymPy symbols</code> <p>Symbols forming the edges of the block.</p> <code>#</code> <code>_alphabet (Alphabet</code> <p>Alphabet used for letters in the block.</p> <code>#</code> <code>_expression (SymPy expression</code> <p>SymPy product representing the block.</p> <p>Initializes a Block.</p> <p>A Block can be either a valid block or the zero block. It is internally represented by a list of factors <code>_x_factors</code> and a list of edge symbols <code>_edges</code>.</p> The block can be initialized from <ul> <li>A string <code>expression</code> in the form \"x_0(1,a_1)x_1...(1,a_m)x_m\"   (handling powers '^' or '*' and product symbols '', '.', or concatenation),</li> <li>Directly from <code>_x_factors</code> and <code>_edges</code> lists,</li> </ul> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>String representation of the block.</p> <code>None</code> <code>alphabet</code> <code>Alphabet</code> <p>Alphabet defining the letters. Defaults to an empty Alphabet.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>Product symbol to use ('', '*', or '.'). Inferred from the expression if None.</p> <code>None</code> <code>x_factors</code> <code>list of SymPy expressions or int</code> <p>Factors x_0, ..., x_k of the block.</p> <code>[int(0)]</code> <code>edges</code> <code>list of SymPy symbols</code> <p>Edge symbols a_1, ..., a_k corresponding to the block.</p> <code>None</code>"},{"location":"reference/#InDelsTopo.Block.get_face","title":"<code>get_face</code>","text":"<p>Return the face \u03c3(indices_plus, indices_minus) of the block \u03c3.</p> <p>indices_plus and indices_minus are disjoint subsets of {1, ..., m}, where m is the dimension of the block. They must be given as lists of integers, and may be empty. The output is the block \u03c3(indices_plus, indices_minus), which is either a valid Block of dimension m \u2212 |indices_plus \u222a indices_minus| or the zero Block.</p> <p>Parameters:</p> Name Type Description Default <code>indices_plus</code> <code>list of int</code> <p>Indices in {1, ..., m} of edges (1, a_i) collapsed to a_i.</p> required <code>indices_minus</code> <code>list of int</code> <p>Indices in {1,..., m} of edges (1, a_i) collapsed to 1.</p> required <p>Returns:</p> Name Type Description <code>face</code> <code>Block</code> <p>The resulting face block \u03c3(indices_plus, indices_minus) if valid,  or the zero Block, otherwise.</p>"},{"location":"reference/#InDelsTopo.Block.get_upper_facets","title":"<code>get_upper_facets</code>","text":"<p>Return the list of upper facets of the block.</p> <p>Each upper facet is obtained by collapsing a single edge (1, a_i) to a_i, for i = 1, ..., m, where m is the dimension of the block.</p> <p>Returns:</p> Name Type Description <code>upper_facets</code> <code>list[Block]</code> <p>A list of Blocks representing the upper facets of the block.</p>"},{"location":"reference/#InDelsTopo.Block.get_lower_facets","title":"<code>get_lower_facets</code>","text":"<p>Return the list of lower facets of the block.</p> <p>Each lower facet is obtained by collapsing a single edge (1, a_i) to 1, for i = 1, ..., m, where m is the dimension of the block. Invalid blocks are excluded from the output.</p> <p>Returns:</p> Type Description <p>list of Block: A list of valid Blocks representing the lower facets of the block.</p>"},{"location":"reference/#InDelsTopo.Block.get_all_facets","title":"<code>get_all_facets</code>","text":"<p>Return all facets of the block. Combines both the upper and lower facets of the block.</p> <p>Returns:</p> Type Description <p>list of Block: A list of Blocks representing all facets of the block.</p>"},{"location":"reference/#InDelsTopo.Block.get_all_faces","title":"<code>get_all_faces</code>","text":"<p>Return all faces of the block, ordered by dimension.</p> <p>Faces are obtained recursively by taking all facets of the block, then all facets of those facets, and so on, down to dimension 0.</p> <p>Parameters:</p> Name Type Description Default <code>include_self</code> <code>bool</code> <p>If True, include the block itself in the returned list. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>list of Block: A list of Blocks representing all faces, orted by increasing dimension.</p>"},{"location":"reference/#InDelsTopo.Block.get_vertex","title":"<code>get_vertex</code>","text":"<p>Return the vertex v_I(\u03c3) of the block determined by a sequence of I = indices.</p> <p>The vertex is obtained by collapsing the edges (1,a_i) indexed by 'I' into a_i, and the remaining ones to 1. Returns the vertex as a 0-block, or as a SymPy expression if as_word=True.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>list of int</code> <p>Indices in {1,..., dim(\u03c3)}</p> required <code>as_word</code> <code>bool</code> <p>If True, return the vertex as a SymPy expression (word). If False, return the corresponding Block. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Block or SymPy Expression: The resulting vertex as a Block or Sympy expression,</p> <p>depending on <code>as_word</code>.</p>"},{"location":"reference/#InDelsTopo.Block.get_all_vertices","title":"<code>get_all_vertices</code>","text":"<p>Return all vertices of the block.</p> <p>Parameters:</p> Name Type Description Default <code>as_words</code> <code>bool</code> <p>If True, return vertices as SymPy expressions (words). If False, return them as Block objects. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>list of Block or SymPy Expression: All vertices of the block as Blocks</p> <p>or words, depending on <code>as_words</code>.</p>"},{"location":"reference/#InDelsTopo.Block.boundary","title":"<code>boundary</code>","text":"<p>Computes the boundary of a block.</p>"},{"location":"reference/#InDelsTopo.Chain","title":"<code>Chain</code>","text":"<p>               Bases: <code>ChainBlockBase</code></p> <p>Represents a chain in the Insertion Chain Complex: a linear combination of valid blocks with integer coefficients.</p> <p>It can be initialized from a string expression, a list of coefficients and blocks, or a dictionary mapping blocks to coefficients.</p> <p>Supports algebraic operations (addition, subtraction, and scalar multiplication), equality checking, string and LaTeX representations, and computation of the boundary.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Maximum dimension among the blocks in the chain, or -1 if empty.</p> <code>_expression(SymPy</code> <code>expression</code> <p>represents the chain as a sum of block expressions.</p> <code>_alphabet</code> <code>Alphabet</code> <p>The Alphabet instance used for all blocks in the chain.</p> <code>_dict_blocks</code> <code>dict</code> <p>(for internal use only) dictionary mapping Block objects to integer coefficients.</p> <code>_prod_symbol</code> <code>str</code> <p>Either '', '*', or '.'.</p> <p>Represents a chain in the Insertion Chain Complex: a linear combination of valid blocks with integer coefficients.</p> <p>Each term can include an integer coefficient followed by a block, e.g., '2abc(1,a)b^ac(1,b)ac - (1,c)(1,a)b^2'.</p> The class can be initialized from <ul> <li>a string expression (preferred way for end users),</li> <li>a list of coefficients and blocks, or</li> <li>a dictionary mapping blocks to coefficients.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>Chain written as a string of blocks. This is the preferred way for end users to construct a chain.</p> <code>None</code> <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object defining the set of letters. If set to None, a new empty alphabet is created.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>Product symbol to use in blocks. Must be one of {'', '', '.'}. If None, it is inferred from the expression: '' if '*' appears, '.' if '.' appears, or '' otherwise.</p> <code>None</code> <code>list_coeffs</code> <code>list of int</code> <p>Integer coefficients of the chain terms. Must be provided together with <code>list_blocks</code>. Ignored if <code>expression</code> or <code>dict_blocks</code> is given.</p> <code>None</code> <code>list_blocks</code> <code>list of Block</code> <p>Block objects corresponding to the coefficients in <code>list_coeffs</code>. Ignored if <code>expression</code> or <code>dict_blocks</code> is given.</p> <code>None</code> <code>dict_blocks</code> <code>dict</code> <p>Dictionary mapping Block objects to integer coefficients. If provided, it takes precedence over <code>expression</code>,<code>list_coeffs</code>, and <code>list_blocks</code>.</p> <code>None</code>"},{"location":"reference/#InDelsTopo.Chain.boundary","title":"<code>boundary</code>","text":"<p>Return the boundary of the chain as a new Chain.</p>"},{"location":"reference/#InDelsTopo.Chain.get_dict_blocks","title":"<code>get_dict_blocks</code>","text":"<p>Return a copy of the internal blocks dictionary.</p>"},{"location":"reference/#InDelsTopo.Alphabet","title":"<code>Alphabet</code>","text":"<p>Represents an alphabet of symbols used to build words.</p> <p>Each symbol in the alphabet is represented as a noncommutative SymPy symbol. For every letter, an associated \"edge\" symbol (or 1-block symbol) is also created. For example, the letter 'a' has a corresponding edge symbol '(1,a)'. Internally, these symbols are handled as elements of a noncommutative SymPy monoid, allowing symbolic manipulations of words as products.</p> <p>This class provides methods to: - Add individual letters. - Update the alphabet with multiple new letters. - Convert words (sequences of letters) into symbolic products of letters.</p> <p>Attributes:</p> Name Type Description <code>letters</code> <code>dict</code> <p>Maps letter strings to their SymPy symbol representation.</p> <code>edges</code> <code>dict</code> <p>Maps letter strings to their corresponding edge (1-block) symbols.</p> <code>letters_str</code> <code>list</code> <p>List of letter strings currently in the alphabet.</p> <p>Initialize an Alphabet with optional letters.</p> <p>Parameters:</p> Name Type Description Default <code>letters_str</code> <code>list of str</code> <p>Initial letters for the alphabet. If None, an empty alphabet is created. Duplicate letters are removed.</p> <code>None</code> Side Effects <p>Initializes the following attributes:     - letters (dict): Maps letter strings to SymPy symbols.     - edges (dict): Maps letter strings to corresponding edge symbols.     - letters_str (list): List of unique letter strings in the alphabet.</p>"},{"location":"reference/#InDelsTopo.Alphabet.get","title":"<code>get</code>","text":"<p>Return the symbolic representation of a letter or its edge.</p> <p>Parameters:</p> Name Type Description Default <code>letter</code> <code>str</code> <p>The letter to retrieve.</p> required <code>dim</code> <code>int</code> <p>Dimension; 0 for the letter symbol, 1 for the edge symbol. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <p>SymPy.Symbol: The corresponding SymPy symbol.</p>"},{"location":"reference/#InDelsTopo.Alphabet.add_letter","title":"<code>add_letter</code>","text":"<p>Add a new letter to the alphabet if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The new letter to add.</p> required"},{"location":"reference/#InDelsTopo.Alphabet.update_letters","title":"<code>update_letters</code>","text":"<p>Add multiple letters to the alphabet, ignoring duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>letters_str</code> <code>iterable of str</code> <p>letters to add.</p> required"},{"location":"reference/#InDelsTopo.Alphabet.cast_word","title":"<code>cast_word</code>","text":"<p>Convert a word (sequence of letters) into a symbolic product.</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>iterable of str</code> <p>The word to convert, as a list of symbols or a string.</p> required <code>check_letters</code> <code>bool</code> <p>If True, updates the alphabet with any new letters found in the word. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>expression</code> <code>Expr</code> <p>SymPy expression of the word, using the symbols in this alphabet.</p>"},{"location":"reference/#InDelsTopo.Filtration","title":"<code>Filtration</code>","text":"<p>Represents a lower-star filtration on a Letter Insertion Chain Complex C[W], for a set of words W with associated heights.</p> <p>It stores the blocks of the complex at each dimension with their corresponding heights. Provides methods for computing the Euler Characteristic Curve, persistent homology barcodes (with Z/Z2 coefficients), and a graphical representation of (accurate for low dimensions).</p> <p>One can access the k-th dimensional blocks by indexing the filtration as 'K[k]'. This returns a dictionary mapping each k-block to its height.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Maximum dimension of the filtration.</p> <code>filtration_dict</code> <code>dict</code> <p>Maps dimension d to a dictionary of blocks and their heights.</p> <code>filtration_values</code> <code>list</code> <p>Sorted list of heights used in the filtration.</p> <code>_alphabet</code> <code>Alphabet</code> <p>Alphabet containing all symbols in W.</p> <code>_prod_symbol</code> <code>str</code> <p>Product symbol used for constructing blocks ('*', '.', or '' for concatenation).</p> <code>_positions_dict</code> <code>dict or None</code> <p>Stores vertex positions for graph representations.</p> Notes <ul> <li>It initializes as an empty filtration. It can be made into the filtration of insertion chain     complexes of a set of words <code>W</code> by using the method <code>compute_d_skeleton(W, heights)</code>.</li> <li>Blocks can be added or removed by using the methods <code>add_blocks</code> and <code>remove_blocks</code>.</li> </ul> <p>Example: <pre><code>&gt;&gt;&gt; W = [\"ab\", \"aab\", \"abb\"]\n&gt;&gt;&gt; heights = [0.1, 0.3, 0.5]\n&gt;&gt;&gt; K = Filtration() # Creates an empty complex\n&gt;&gt;&gt; K.compute_d_skeleton(W, heights, max_dim=5) # makes K = a filtration of C[W]\n&gt;&gt;&gt; K[1]  # Access 1-dimensional blocks and their heights\n{a(1,a)b: 0.3, ab(1,b): 0.5}\n</code></pre></p> <p>Returns an empty Filtration object.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object defining valid symbols. If None, a new empty <code>Alphabet</code> is created.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>The product symbol to use. Must be one of {'', '', '.'}. If None, it is inferred from the expression: set to '' if '*' appears, to '.' if '.' appears, or to '' (concatenation) otherwise.</p> <code>None</code>"},{"location":"reference/#InDelsTopo.Filtration.compute_d_skeleton","title":"<code>compute_d_skeleton</code>","text":"<p>Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W]. This method replaces any existing data in the Filtration with a new complex supported on <code>W</code>.</p> <p>This method constructs all valid blocks up to the specified maximum dimension (<code>max_dim</code>) for a given set of words <code>W</code> with associated heights. It begins by computing the 0- and 1-skeletons (vertices and edges), then iteratively extends to higher dimensions.</p> <p>It updates the internal <code>filtration_dict</code> to the blocks supported on <code>W</code>.</p> <p>Parameters:</p> Name Type Description Default <code>W</code> <code>list of str or Block</code> <p>List of words (or blocks, if <code>already_blocks=True</code>) forming the base of the complex.</p> required <code>heights</code> <code>list of float</code> <p>Height values associated with each word. If None, defaults to ones.</p> <code>None</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of the skeleton to compute. Defaults to 10.</p> <code>10</code> <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object used together with the internal <code>self._alphabet</code> and any letters inferred from <code>W</code>. If provided, its symbols are merged with <code>self._alphabet</code>; otherwise, the new symbols are inferred entirely from the given words.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>Product symbol for block construction ('*', '.', or ''). If None, inferred automatically.</p> <code>None</code> <code>check_duplicates</code> <code>bool</code> <p>Whether to verify that input words are unique. Defaults to True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, assumes the input <code>W</code> is already a list of <code>Block</code> objects instead of strings. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints progress information during computation.</p> <code>False</code> <p>Example: <pre><code>&gt;&gt;&gt; W = ['a*b', 'a*b*b', 'a*a*b','']\n&gt;&gt;&gt; K = Filtration()\n&gt;&gt;&gt; K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2)\n&gt;&gt;&gt; K[1]\n{a*b*(1,b): 0.3, a*(1,a)*b: 0.2}\n</code></pre></p>"},{"location":"reference/#InDelsTopo.Filtration.add_blocks","title":"<code>add_blocks</code>","text":"<p>Add new blocks to the Filtration.</p> <p>Extends the current Filtration by inserting additional blocks and their faces. This method allows dynamically modifying an existing filtration while ensuring, as much as possible, that the result remains a valid filtration (i.e., if \u03b1 \u2264 \u03b2, then F.get_complex(\u03b1) \u2286 F.get_complex(\u03b2)).</p> <p>Intended for expert use only, since the resulting structure may not always be a full Insertion Chain Complex C[W], but rather a subcomplex if some supporting blocks are missing. The result may depend on the order in which the blocks are provided.</p> <p>The behavior depends on the value of <code>update_values</code>:</p> <pre><code>- If ``update_values=True``, the heights of existing faces and super-faces\n  are updated as needed to maintain the filtration property. This ensures\n  that the new blocks can be inserted with the provided heights.\n\n- If ``update_values=False`` (default), the method adds the blocks only if\n  their heights are consistent with the current filtration. Otherwise, the\n  maximum among the heights of their faces is used instead.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list[Block] or list[str]</code> <p>List of blocks to be added to the Filtration. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing <code>Block</code> objects.</p> required <code>list_heights</code> <code>list[float] or float or None</code> <p>Heights assigned to each block. If a single numeric value is provided, it is used for all blocks. If None, all blocks receive height 1.</p> <code>None</code> <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation (e.g., '*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>already_blocks</code> <code>bool</code> <p>If True, elements of <code>list_blocks</code> are assumed to be valid <code>Block</code> objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code> <code>update_values</code> <code>bool</code> <p>If True, existing heights of faces and super-faces are updated as needed to maintain consistency when inserting the new blocks. If False (default), only new faces are added and the provided heights are applied when valid; otherwise, the lowest consistent height is used instead.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If <code>list_heights</code> is a list whose length does not match <code>list_blocks</code>.</li> <li>If <code>list_heights</code> is not a list, a numeric value, or None.</li> <li>If the height of a block is lower than the height of one of its faces   already present in the filtration (when <code>update_values=False</code>).</li> </ul> Notes <ul> <li>The internal alphabet and product symbol are updated to ensure consistency.</li> <li>The resulting filtration may vary depending on the order in which blocks   are inserted.</li> <li>Updating an existing filtration in this way may be more computationally   expensive than reconstructing a new Filtration directly from a set of words.</li> </ul>"},{"location":"reference/#InDelsTopo.Filtration.remove_blocks","title":"<code>remove_blocks</code>","text":"<p>Remove blocks from the Filtration.</p> <p>Deletes specified blocks and optionally their super-faces from the Complex. Intended for expert use only, since the resulting structure may not be a full Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks are missing.</p> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list of Block or string</code> <p>A list of blocks to remove. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing Block objects.</p> required <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation ( '*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>include_upfaces</code> <code>bool</code> <p>If True, all super faces of the specified blocks are also removed, so the result is a subcomplex. Default is True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, the elements of <code>list_blocks</code> are assumed to be valid Block objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code>"},{"location":"reference/#InDelsTopo.Filtration.get_complex","title":"<code>get_complex</code>","text":"<p>Constructs and returns a Complex object that includes all blocks from the filtration whose height is less than or equal to the specified value. The construction can also be limited to a specified maximum dimension.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>float or int</code> <p>The maximum filtration value to include. If None, the largest available filtration value is used.</p> <code>None</code> <code>max_dim</code> <code>int</code> <p>The maximum dimension to include in the complex. If None, the full dimension of the filtration is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>complex</code> <code>Complex</code> <p>A Complex object containing all blocks up to the specified height and dimension.</p>"},{"location":"reference/#InDelsTopo.Filtration.get_euler_curve","title":"<code>get_euler_curve</code>","text":"<p>This method evaluates the Euler characteristic of the complex at different filtration heights and returns the resulting curve as paired x- and y-values.</p> <p>Parameters:</p> Name Type Description Default <code>x_values</code> <code>list of float or int</code> <p>Filtration heights at which to compute the Euler characteristic. If None, all existing filtration values are used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <ul> <li>list of float or int: Sorted filtration heights (x-values).</li> <li>list of int: Corresponding Euler characteristic values (y-values).</li> </ul>"},{"location":"reference/#InDelsTopo.Filtration.get_persistent_homology_barcodes","title":"<code>get_persistent_homology_barcodes</code>","text":"<p>Compute persistent homology barcodes for the filtration using Z2 coefficients.</p> <p>The method performs a lower-star filtration on the complex according to the vertex heights and computes persistent homology up to the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>max_dim</code> <code>int</code> <p>Maximum dimension to compute accurately. The skeleton of dimension up to max_dim+1 is used for this computation if it was previously computed. If None or greater than the filtration's dimension, all dimensions are included.</p> <code>None</code> <code>inf_value</code> <code>float</code> <p>Value to assign to features that do not die within the filtration. Defaults to infinity.</p> <code>inf</code> <code>get_height_indices</code> <code>bool</code> <p>If True, also return the indices corresponding to the birth and death heights in the filtration. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>dict or tuple: - If <code>get_height_indices=False</code>: A dictionary mapping dimension <code>d</code>   to a list of tuples <code>(birth, death)</code> representing persistent homology intervals. - If <code>get_height_indices=True</code>: A tuple of two dictionaries:     1. Barcodes as above.     2. Corresponding indices of birth and death heights in <code>filtration_values</code>.</p> Notes <p>The algorithm uses a boundary matrix over Z2 and reduces it following the standard persistence algorithm (see arxiv:1506.08903). Features that never die are assigned <code>inf_value</code> as their death time.</p>"},{"location":"reference/#InDelsTopo.Filtration.get_graph","title":"<code>get_graph</code>","text":"<p>Generate a graphical representation of the filtration up to a specified dimension.</p> <p>Positions of vertices can be computed automatically or provided manually. Only accurate for low-dimensional complexes (typically dim &lt;= 3).</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>float</code> <p>Maximum height value for including blocks in the graph. Defaults to the maximum filtration value.</p> <code>None</code> <code>height_id</code> <code>int</code> <p>Index into the sorted list of filtration values. Used if <code>height</code> is None. Defaults to None.</p> <code>None</code> <code>show_labels</code> <code>bool</code> <p>Whether to display labels on the vertices. Defaults to True.</p> <code>True</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of blocks to include in the graph. Defaults to 5.</p> <code>5</code> <code>positions</code> <code>dict</code> <p>Dictionary of vertex positions. If None, positions are computed automatically. Once computed, they are reused everytime this method is called, unless recompute is set to True.</p> <code>None</code> <code>initial_positions</code> <code>dict</code> <p>Initial positions used to seed the automatic layout algorithm.</p> <code>None</code> <code>fixed</code> <code>list or None</code> <p>List of vertex keys to fix in place when computing positions. Defaults to None.</p> <code>None</code> <code>recompute</code> <code>bool</code> <p>Whether to recompute vertex positions even if already stored. Defaults to False.</p> <code>False</code> <code>colors_by_dim</code> <code>list of str</code> <p>List of colors to use for each dimension. If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].</p> <code>None</code> <code>ax</code> <code>Axes3DSubplot</code> <p>A Matplotlib Axes object to draw the plot on. If None, a new figure and axes are created. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.</p>"},{"location":"reference/#InDelsTopo.Filtration.get_alphabet","title":"<code>get_alphabet</code>","text":"<p>Returns the alphabet attribute.</p>"},{"location":"reference/#InDelsTopo.Filtration.get_block_height","title":"<code>get_block_height</code>","text":"<p>Returns the height of the block in the filtration or None if it is not in the filtration.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block or string</code> <p>A block to check its height. If <code>already_blocks</code> is False (default),</p> required <code>already_block</code> <code>bool</code> <p>If True, <code>block</code> is assumed to be a valid Block object. If False (default), the method attempts to convert the input into a block.</p> <code>False</code>"},{"location":"reference/#InDelsTopo.Complex","title":"<code>Complex</code>","text":"<p>Represents an Insertion Chain Complex C[W] for a set of words W.</p> <p>The class stores the blocks of the complex in each dimension and provides methods to compute topological invariants such as the Euler characteristic and Betti numbers (over Z_2 or Z when using a SageMath kernel). It also supports graphical visualization of the complex in low dimensions.</p> <p>The k-dimensional blocks can be accessed via indexing syntax: <code>K[k]</code> returns the list of k-blocks.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Maximum dimension of the complex.</p> <code>complex_dict</code> <code>dict[int, list[Block]]</code> <p>Maps each dimension to its corresponding list of blocks.</p> <code>height</code> <code>float | None</code> <p>Height value associated with the complex.</p> <code>_alphabet</code> <code>Alphabet</code> <p>Alphabet object containing all symbols used in W.</p> <code>_prod_symbol</code> <code>str</code> <p>Product symbol used in the blocks.</p> <code>_positions_dict</code> <code>dict | None</code> <p>Stores vertex positions for graphical visualization.</p> Notes <ul> <li>This class can be used to build and analyze Insertion Chain Complexes directly,   or as a sublevel complex of a filtration.</li> <li>Homology computations over Z require SageMath; otherwise, only Z_2 computations   are available using SciPy.</li> <li>It initializes as an empty complex. It can be made into the insertion chain complex     of a set of words <code>W</code> by using the method <code>compute_d_skeleton(W)</code>.</li> <li>Blocks can be added or removed by using the methods <code>add_blocks</code> and <code>remove_blocks</code>.</li> </ul> <p>Example: <pre><code>&gt;&gt;&gt; W = [\"ab\", \"aab\", \"abb\"]\n&gt;&gt;&gt; K = Complex() # Creates an empty complex\n&gt;&gt;&gt; K.compute_d_skeleton(W) # makes K = C[W]\n&gt;&gt;&gt; K[1]  # Access 1-dimensional blocks\n[a(1,a)b, ab(1,b)]\n</code></pre></p> <p>Initialize an Insertion Chain Complex.</p> <p>This constructor creates a new complex object, which can either start empty (with no blocks) or be initialized from a given dictionary of blocks. Optionally, the complex can store a height value, useful when representing a level in a filtration.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>Alphabet | None</code> <p>The alphabet containing all symbols to be used. Defaults to None.</p> <code>None</code> <code>prod_symbol</code> <code>str | None</code> <p>Product symbol used for block construction, Must be one of {'', '', '.'}. If None, it is inferred from the expression: set to '' if '*' appears, to '.' if '.' appears, or to '' (concatenation) otherwise.</p> <code>None</code> <code>complex_dict</code> <code>dict[int, list[Block]] | None</code> <p>Mapping from dimension <code>d</code> to the list of d-dimensional blocks. If provided, it initializes the complex structure directly. Defaults to None.</p> <code>None</code> <code>height</code> <code>float | None</code> <p>Height value associated with the complex, used when part of a filtration. Defaults to None.</p> <code>None</code>"},{"location":"reference/#InDelsTopo.Complex.compute_d_skeleton","title":"<code>compute_d_skeleton</code>","text":"<p>Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W]. This method replaces any existing data in the Complex with a new complex supported on <code>W</code>.</p> <p>This method constructs all valid blocks up to the specified maximum dimension (<code>max_dim</code>) for a given set of words <code>W</code>. It begins by computing the 0- and 1-skeletons (vertices and edges), then iteratively extends to higher dimensions.</p> <p>It updates the internal <code>complex_dict</code> to the blocks supported on <code>W</code>.</p> <p>Parameters:</p> Name Type Description Default <code>W</code> <code>list of str or Block</code> <p>List of words (or blocks, if <code>already_blocks=True</code>) forming the base of the complex.</p> required <code>height</code> <code>float</code> <p>Height value associated with the complex, used when part of a filtration. Defaults to None.</p> <code>None</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of the skeleton to compute. Defaults to 10.</p> <code>10</code> <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object used together with the internal <code>self._alphabet</code> and any letters inferred from <code>W</code>. If provided, its symbols are merged with <code>self._alphabet</code>; otherwise, the new symbols are inferred entirely from the given words.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>Product symbol for block construction ('*', '.', or ''). If None, inferred automatically.</p> <code>None</code> <code>check_duplicates</code> <code>bool</code> <p>Whether to verify that input words are unique. Defaults to True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, assumes the input <code>W</code> is already a list of <code>Block</code> objects instead of strings. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints progress information during computation.</p> <code>False</code> <p>Example: <pre><code>&gt;&gt;&gt; W = ['a*b', 'a*b*b', 'a*a*b','']\n&gt;&gt;&gt; K = Filtration()\n&gt;&gt;&gt; K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2)\n&gt;&gt;&gt; K[1]\n{a*b*(1,b): 0.3, a*(1,a)*b: 0.2}\n</code></pre></p>"},{"location":"reference/#InDelsTopo.Complex.get_maximal_blocks","title":"<code>get_maximal_blocks</code>","text":"<p>Return the maximal blocks of the complex, ordered by subfaces.</p> <p>A block is maximal if it is not a subface of any higher-dimensional block. The method identifies all such maximal blocks in each dimension and returns them as a dictionary.</p> <p>Returns:</p> Type Description <p>dict[int, list[Block]]: A dictionary mapping each dimension to a list</p> <p>of maximal blocks (i.e., blocks not covered by higher-dimensional ones).</p> Notes <ul> <li>Empty dimensions are removed from the output dictionary.</li> </ul>"},{"location":"reference/#InDelsTopo.Complex.get_complex","title":"<code>get_complex</code>","text":"<p>Return a subcomplex of the current complex up to the specified dimension.</p> <p>If <code>max_dim</code> is not provided or is greater than or equal to the current dimension, the method returns the complex itself. Otherwise, it returns a new <code>Complex</code> object containing only the blocks up to dimension <code>max_dim</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_dim</code> <code>int or None</code> <p>Maximum dimension of blocks to include in the returned complex. If None or greater than the complex dimension, the full complex is returned.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Complex</code> <p>A subcomplex containing blocks up to dimension <code>max_dim</code>.</p>"},{"location":"reference/#InDelsTopo.Complex.add_blocks","title":"<code>add_blocks</code>","text":"<p>Add new blocks to the Complex.</p> <p>Extends the current Complex by inserting additional blocks and their faces. Intended for expert use only, since the resulting structure may not be a full Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks are missing.</p> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list[Block] or list[str]</code> <p>List of blocks to be added to the Filtration. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing <code>Block</code> objects.</p> required <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation ('*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>already_blocks</code> <code>bool</code> <p>If True, elements of <code>list_blocks</code> are assumed to be valid <code>Block</code> objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code> Notes <p>The internal alphabet and product symbol are updated to ensure consistency.</p>"},{"location":"reference/#InDelsTopo.Complex.remove_blocks","title":"<code>remove_blocks</code>","text":"<p>Remove blocks from the Complex.</p> <p>Deletes specified blocks and optionally their super-faces from the Complex. Intended for expert use only, since the resulting structure may not be a full Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks are missing.</p> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list of Block or string</code> <p>A list of blocks to remove. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing Block objects.</p> required <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation ( '*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>include_upfaces</code> <code>bool</code> <p>If True, all super faces of the specified blocks are also removed, so the result is a subcomplex. Default is True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, the elements of <code>list_blocks</code> are assumed to be valid Block objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code>"},{"location":"reference/#InDelsTopo.Complex.euler_characteristic","title":"<code>euler_characteristic</code>","text":"<p>This method computes the Euler characteristic of the complex.</p>"},{"location":"reference/#InDelsTopo.Complex.get_graph","title":"<code>get_graph</code>","text":"<p>Generate a graphical representation of the complex up to a specified dimension.</p> <p>Positions of vertices can be computed automatically or provided manually. Only accurate for low-dimensional complexes (typically dim &lt;= 3).</p> <p>Parameters:</p> Name Type Description Default <code>show_labels</code> <code>bool</code> <p>Whether to display labels on the vertices. Defaults to True.</p> <code>True</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of blocks to include in the graph. Defaults to 5.</p> <code>5</code> <code>positions</code> <code>dict</code> <p>Dictionary of vertex positions. If None, positions are computed automatically. Once computed, they are reused everytime this method is called, unless recompute is set to True.</p> <code>None</code> <code>initial_positions</code> <code>dict</code> <p>Initial positions used to seed the automatic layout algorithm.</p> <code>None</code> <code>fixed</code> <code>list or None</code> <p>List of vertex keys to fix in place when computing positions. Defaults to None.</p> <code>None</code> <code>recompute</code> <code>bool</code> <p>Whether to recompute vertex positions even if already stored. Defaults to False.</p> <code>False</code> <code>colors_by_dim</code> <code>list of str</code> <p>List of colors to use for each dimension. If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].</p> <code>None</code> <code>ax</code> <code>Axes3DSubplot</code> <p>A Matplotlib Axes object to draw the plot on. If None, a new figure and axes are created. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.</p>"},{"location":"reference/#InDelsTopo.Complex.get_betti_numbers_z2","title":"<code>get_betti_numbers_z2</code>","text":"<p>Returns the betti numbers in Z_2 coefficients up to the specified dimension max_dim.</p>"},{"location":"reference/#InDelsTopo.Complex.get_chain_complex_sage","title":"<code>get_chain_complex_sage</code>","text":"<p>Construct and return the associated chain complex as a SageMath object.</p> <p>This method is intended to be used in a SageMath kernel. It builds a chain complex using Sage's <code>ChainComplex()</code> constructor. Optionally, it can also return the blocks sorted within each dimension.</p> <p>Parameters:</p> Name Type Description Default <code>get_ordered_blocks</code> <code>bool</code> <p>If True, also return the blocks ordered by their expressions within each dimension. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>ChainComplex or tuple[ChainComplex, dict[int, list[Block]]]: - If <code>get_ordered_blocks</code> is False, returns a ChainComplex object   representing the boundary operators. - If <code>get_ordered_blocks</code> is True, returns a tuple <code>(ChainComplex, Blocks_ordered)</code>,   where <code>Blocks_ordered</code> is a dictionary of lists of blocks sorted by expression.</p> <p>Notes:     - Requires SageMath to be installed and accessible in the current environment.     - If SageMath is not found, the function prints a warning and returns None.     - Any other errors during construction are caught and printed.</p>"},{"location":"reference/#InDelsTopo.Complex.get_homology_sage","title":"<code>get_homology_sage</code>","text":"<p>Return the homology of the associated chain complex using SageMath.</p> <p>This method should be run in a SageMath kernel. It constructs a SageMath chain complex and computes its homology using Sage's built-in <code>homology()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>save_chain_complex</code> <code>bool</code> <p>If True, the chain complex is saved as an attribute                        (<code>self._sage_chain_complex</code>) to speed up future computations.</p> <code>False</code> <code>used_saved_chain_complex</code> <code>bool</code> <p>If True, it will attempt to use the saved chain_complex                             attribute, otherwise, it will be computed from scratch.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments passed directly to SageMath's <code>homology()</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The homology object returned by SageMath.</p>"},{"location":"reference/#InDelsTopo.Complex.get_alphabet","title":"<code>get_alphabet</code>","text":"<p>Returns the alphabet attribute.</p>"}]}