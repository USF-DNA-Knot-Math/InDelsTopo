{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/","title":"InDelsTopo API Reference","text":"<p>InDelsTopo: A Python package to analyze topological properties of sets of words when their main source of variation are insertions and deletions, using the Insertion Chain Complex framework.</p>"},{"location":"reference/#InDelsTopo.__version__","title":"<code>__version__ = '0.1.0'</code>  <code>module-attribute</code>","text":""},{"location":"reference/#InDelsTopo.Alphabet","title":"<code>Alphabet</code>","text":"<p>Represents an alphabet of symbols used to build words.</p> <p>Each symbol in the alphabet is represented as a noncommutative SymPy symbol. For every letter, an associated \"edge\" symbol (or 1-block symbol) is also created. For example, the letter 'a' has a corresponding edge symbol '(1,a)'. Internally, these symbols are handled as elements of a noncommutative SymPy monoid, allowing symbolic manipulations of words as products.</p> <p>This class provides methods to: - Add individual letters. - Update the alphabet with multiple new letters. - Convert words (sequences of letters) into symbolic products of letters.</p> <p>Attributes:</p> Name Type Description <code>letters</code> <code>dict</code> <p>Maps letter strings to their SymPy symbol representation.</p> <code>edges</code> <code>dict</code> <p>Maps letter strings to their corresponding edge (1-block) symbols.</p> <code>letters_str</code> <code>list</code> <p>List of letter strings currently in the alphabet.</p> Source code in <code>InDelsTopo/alphabet.py</code> <pre><code>class Alphabet:\n    \"\"\"\n    Represents an alphabet of symbols used to build words.\n\n    Each symbol in the alphabet is represented as a noncommutative SymPy symbol.\n    For every letter, an associated \"edge\" symbol (or 1-block symbol) is also\n    created. For example, the letter 'a' has a corresponding edge symbol '(1,a)'.\n    Internally, these symbols are handled as elements of a noncommutative SymPy\n    monoid, allowing symbolic manipulations of words as products.\n\n    This class provides methods to:\n    - Add individual letters.\n    - Update the alphabet with multiple new letters.\n    - Convert words (sequences of letters) into symbolic products of letters.\n\n    Attributes:\n        letters (dict): Maps letter strings to their SymPy symbol representation.\n        edges (dict): Maps letter strings to their corresponding edge (1-block) symbols.\n        letters_str (list): List of letter strings currently in the alphabet.\n    \"\"\"\n\n    def __init__(self, letters_str=None):\n        \"\"\"\n        Initialize an Alphabet with optional letters.\n\n        Args:\n            letters_str (list of str, optional): Initial letters for the alphabet.\n                If None, an empty alphabet is created. Duplicate letters are removed.\n\n        Side Effects:\n            Initializes the following attributes:\n                - letters (dict): Maps letter strings to SymPy symbols.\n                - edges (dict): Maps letter strings to corresponding edge symbols.\n                - letters_str (list): List of unique letter strings in the alphabet.\n        \"\"\"\n        letters = {}\n        edges = {}\n        letters_str = list(set(letters_str)) if letters_str is not None else []\n        for symbol in letters_str:\n            letters[symbol] = sym.Symbol(symbol, commutative=False)\n            edges[symbol] = sym.Symbol(\"(1,_)\".replace(\"_\", symbol), commutative=False)\n\n        self.letters = letters\n        self._edges = edges\n        self.letters_str = letters_str\n\n    def get(self, letter, dim=0):\n        \"\"\"\n        Return the symbolic representation of a letter or its edge.\n\n        Args:\n            letter (str): The letter to retrieve.\n            dim (int, optional): Dimension; 0 for the letter symbol,\n                1 for the edge symbol. Defaults to 0.\n\n        Returns:\n            SymPy.Symbol: The corresponding SymPy symbol.\n        \"\"\"\n        if dim == 0:\n            return self.letters[letter]\n        if dim == 1:\n            return self._edges[letter]\n        raise ValueError(\"Dimension dim must be 0 or 1.\")\n\n    def add_letter(self, symbol):\n        \"\"\"\n        Add a new letter to the alphabet if it does not already exist.\n\n        Args:\n            symbol (str): The new letter to add.\n        \"\"\"\n        if symbol not in self.letters_str:\n            self.letters_str.append(symbol)\n            self.letters[symbol] = sym.Symbol(symbol, commutative=False)\n            self._edges[symbol] = sym.Symbol(\n                \"(1,_)\".replace(\"_\", symbol), commutative=False\n            )\n\n    def update_letters(self, letters_str):\n        \"\"\"\n        Add multiple letters to the alphabet, ignoring duplicates.\n\n        Args:\n            letters_str (iterable of str): letters to add.\n        \"\"\"\n        new_letters = set(letters_str).difference(self.letters_str)\n        for symbol in new_letters:\n            self.letters_str.append(symbol)\n            self.letters[symbol] = sym.Symbol(symbol, commutative=False)\n            self._edges[symbol] = sym.Symbol(\n                \"(1,_)\".replace(\"_\", symbol), commutative=False\n            )\n\n    def cast_word(self, word, check_letters=True):\n        \"\"\"\n        Convert a word (sequence of letters) into a symbolic product.\n\n        Args:\n            word (iterable of str): The word to convert, as a list of symbols or a string.\n            check_letters (bool, optional): If True, updates the alphabet with\n                any new letters found in the word. Defaults to True.\n\n        Returns:\n            sympy.Expr: SymPy expression of the word, using the symbols in this alphabet.\n        \"\"\"\n        if check_letters:\n            self.update_letters(word)\n        return sym.prod([self.letters[symbol] for symbol in word], start=int(1))\n\n    def __str__(self):\n        return \"Alphabet with letters: \" + str(sorted(self.letters_str))\n\n    def __repr__(self):\n        return self.__str__()\n</code></pre>"},{"location":"reference/#InDelsTopo.Alphabet.__init__","title":"<code>__init__(letters_str=None)</code>","text":"<p>Initialize an Alphabet with optional letters.</p> <p>Parameters:</p> Name Type Description Default <code>letters_str</code> <code>list of str</code> <p>Initial letters for the alphabet. If None, an empty alphabet is created. Duplicate letters are removed.</p> <code>None</code> Side Effects <p>Initializes the following attributes:     - letters (dict): Maps letter strings to SymPy symbols.     - edges (dict): Maps letter strings to corresponding edge symbols.     - letters_str (list): List of unique letter strings in the alphabet.</p> Source code in <code>InDelsTopo/alphabet.py</code> <pre><code>def __init__(self, letters_str=None):\n    \"\"\"\n    Initialize an Alphabet with optional letters.\n\n    Args:\n        letters_str (list of str, optional): Initial letters for the alphabet.\n            If None, an empty alphabet is created. Duplicate letters are removed.\n\n    Side Effects:\n        Initializes the following attributes:\n            - letters (dict): Maps letter strings to SymPy symbols.\n            - edges (dict): Maps letter strings to corresponding edge symbols.\n            - letters_str (list): List of unique letter strings in the alphabet.\n    \"\"\"\n    letters = {}\n    edges = {}\n    letters_str = list(set(letters_str)) if letters_str is not None else []\n    for symbol in letters_str:\n        letters[symbol] = sym.Symbol(symbol, commutative=False)\n        edges[symbol] = sym.Symbol(\"(1,_)\".replace(\"_\", symbol), commutative=False)\n\n    self.letters = letters\n    self._edges = edges\n    self.letters_str = letters_str\n</code></pre>"},{"location":"reference/#InDelsTopo.Alphabet.add_letter","title":"<code>add_letter(symbol)</code>","text":"<p>Add a new letter to the alphabet if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The new letter to add.</p> required Source code in <code>InDelsTopo/alphabet.py</code> <pre><code>def add_letter(self, symbol):\n    \"\"\"\n    Add a new letter to the alphabet if it does not already exist.\n\n    Args:\n        symbol (str): The new letter to add.\n    \"\"\"\n    if symbol not in self.letters_str:\n        self.letters_str.append(symbol)\n        self.letters[symbol] = sym.Symbol(symbol, commutative=False)\n        self._edges[symbol] = sym.Symbol(\n            \"(1,_)\".replace(\"_\", symbol), commutative=False\n        )\n</code></pre>"},{"location":"reference/#InDelsTopo.Alphabet.cast_word","title":"<code>cast_word(word, check_letters=True)</code>","text":"<p>Convert a word (sequence of letters) into a symbolic product.</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>iterable of str</code> <p>The word to convert, as a list of symbols or a string.</p> required <code>check_letters</code> <code>bool</code> <p>If True, updates the alphabet with any new letters found in the word. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>sympy.Expr: SymPy expression of the word, using the symbols in this alphabet.</p> Source code in <code>InDelsTopo/alphabet.py</code> <pre><code>def cast_word(self, word, check_letters=True):\n    \"\"\"\n    Convert a word (sequence of letters) into a symbolic product.\n\n    Args:\n        word (iterable of str): The word to convert, as a list of symbols or a string.\n        check_letters (bool, optional): If True, updates the alphabet with\n            any new letters found in the word. Defaults to True.\n\n    Returns:\n        sympy.Expr: SymPy expression of the word, using the symbols in this alphabet.\n    \"\"\"\n    if check_letters:\n        self.update_letters(word)\n    return sym.prod([self.letters[symbol] for symbol in word], start=int(1))\n</code></pre>"},{"location":"reference/#InDelsTopo.Alphabet.get","title":"<code>get(letter, dim=0)</code>","text":"<p>Return the symbolic representation of a letter or its edge.</p> <p>Parameters:</p> Name Type Description Default <code>letter</code> <code>str</code> <p>The letter to retrieve.</p> required <code>dim</code> <code>int</code> <p>Dimension; 0 for the letter symbol, 1 for the edge symbol. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <p>SymPy.Symbol: The corresponding SymPy symbol.</p> Source code in <code>InDelsTopo/alphabet.py</code> <pre><code>def get(self, letter, dim=0):\n    \"\"\"\n    Return the symbolic representation of a letter or its edge.\n\n    Args:\n        letter (str): The letter to retrieve.\n        dim (int, optional): Dimension; 0 for the letter symbol,\n            1 for the edge symbol. Defaults to 0.\n\n    Returns:\n        SymPy.Symbol: The corresponding SymPy symbol.\n    \"\"\"\n    if dim == 0:\n        return self.letters[letter]\n    if dim == 1:\n        return self._edges[letter]\n    raise ValueError(\"Dimension dim must be 0 or 1.\")\n</code></pre>"},{"location":"reference/#InDelsTopo.Alphabet.update_letters","title":"<code>update_letters(letters_str)</code>","text":"<p>Add multiple letters to the alphabet, ignoring duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>letters_str</code> <code>iterable of str</code> <p>letters to add.</p> required Source code in <code>InDelsTopo/alphabet.py</code> <pre><code>def update_letters(self, letters_str):\n    \"\"\"\n    Add multiple letters to the alphabet, ignoring duplicates.\n\n    Args:\n        letters_str (iterable of str): letters to add.\n    \"\"\"\n    new_letters = set(letters_str).difference(self.letters_str)\n    for symbol in new_letters:\n        self.letters_str.append(symbol)\n        self.letters[symbol] = sym.Symbol(symbol, commutative=False)\n        self._edges[symbol] = sym.Symbol(\n            \"(1,_)\".replace(\"_\", symbol), commutative=False\n        )\n</code></pre>"},{"location":"reference/#InDelsTopo.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>ChainBlockBase</code></p> <p>Represents a Block in the Insertion Chain Complex.</p> <p>A Block can be a valid block or \"0\" if the provided data corresponds to an invalid block. It has the formal expression x_0(1,a_1)x_1...(1,a_m)x_m, where the a_i are single symbols from an alphabet, and the x_i are words over that alphabet (including possibly the empty word). Internally, blocks are stored as a list of factors x_0, ..., x_k and a list of edge symbols a_1, ..., a_k, represented as SymPy expressions and symbols.</p> <p>Blocks can be initialized from a string expression or directly via x_factors and edges.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Number of edges (dimension) of the block.</p> <code>max_word</code> <code>SymPy expression</code> <p>Maximal word of the block.</p> <code>min_word</code> <code>SymPy expression</code> <p>Minimal word of the block.</p> Internal Attributes <p>_x_factors (list of SymPy expressions or int): Factors of the block. _edges (list of SymPy symbols): Symbols forming the edges of the block. _alphabet (Alphabet): Alphabet used for letters in the block. _expression (SymPy expression): SymPy product representing the block.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>class Block(ChainBlockBase):\n    \"\"\"Represents a Block in the Insertion Chain Complex.\n\n    A Block can be a valid block or \"0\" if the provided data corresponds to an invalid block.\n    It has the formal expression x_0(1,a_1)x_1...(1,a_m)x_m, where the a_i are single symbols\n    from an alphabet, and the x_i are words over that alphabet (including possibly the empty word).\n    Internally, blocks are stored as a list of factors x_0, ..., x_k and a list of edge\n    symbols a_1, ..., a_k, represented as SymPy expressions and symbols.\n\n    Blocks can be initialized from a string expression or directly via x_factors and edges.\n\n    Attributes:\n        dim (int): Number of edges (dimension) of the block.\n        max_word (SymPy expression): Maximal word of the block.\n        min_word (SymPy expression): Minimal word of the block.\n\n    Internal Attributes:\n        _x_factors (list of SymPy expressions or int): Factors of the block.\n        _edges (list of SymPy symbols): Symbols forming the edges of the block.\n        _alphabet (Alphabet): Alphabet used for letters in the block.\n        _expression (SymPy expression): SymPy product representing the block.\n    \"\"\"\n\n    def __init__(\n        self,\n        expression=None,\n        alphabet=None,\n        prod_symbol=None,\n        *,\n        x_factors=[int(0)],\n        edges=None,\n    ):\n        \"\"\"Initializes a Block.\n\n        A Block can be either a valid block or the zero block. It is internally\n        represented by a list of factors `_x_factors` and a list of edge symbols\n        `_edges`.\n\n        The block can be initialized from:\n            - A string `expression` in the form \"x_0(1,a_1)x_1...(1,a_m)x_m\"\n              (handling powers '^' or '**' and product symbols '*', '.', or concatenation),\n            - Directly from `_x_factors` and `_edges` lists,\n\n        Args:\n            expression (str, optional): String representation of the block.\n            _alphabet (Alphabet, optional): Alphabet defining the letters.\n                Defaults to an empty Alphabet.\n            _prod_symbol (str, optional): Product symbol to use ('', '*', or '.').\n                Inferred from the expression if None.\n            _x_factors (list of SymPy expressions or int, optional):\n                Factors x_0, ..., x_k of the block.\n            _edges (list of SymPy symbols, optional): Edge symbols a_1, ..., a_k\n                corresponding to the block.\n        \"\"\"\n        super().__init__()  # initialize base class attributes\n        x_factors = [int(0)] if x_factors is None else x_factors\n        edges = [] if edges is None else edges\n        alphabet = Alphabet([]) if alphabet is None else alphabet\n\n        # Use expression if provided\n        if isinstance(expression, str):\n            if expression == \"1\":\n                x_factors = [int(1)]\n                edges = []\n                prod_symbol = \"\"\n            else:\n                x_factors, edges, alphabet, prod_symbol = _block_str_constructor(\n                    expression, alphabet, prod_symbol\n                )\n\n        if len(x_factors) == 0:\n            self._x_factors = [int(0)]\n            self._edges = []\n            self.dim = -1\n\n        elif len(x_factors) - len(edges) != 1:\n            raise Exception(\"x_factors must be one unit longer than edges.\")\n\n        # Set attributes\n        self._x_factors = x_factors\n        self._edges = edges\n        self.dim = len(edges)\n        self._prod_symbol = prod_symbol\n        self._alphabet = alphabet\n\n        # Get canonical form\n        self._canonical_form()\n\n        # Check is a valid block\n        if not self._is_valid_block():\n            self._x_factors = [int(0)]\n            self._edges = []\n            self.dim = -1\n\n        # Expression\n        edges = [self._alphabet.get(str(a), 1) for a in self._edges] + [sym.sympify(1)]\n        self._expression = sym.prod(\n            [val for pair in zip(self._x_factors, edges) for val in pair]\n        )\n\n        # Maximal and minimal words\n        if self.dim &lt; 0:\n            self.max_word = sym.sympify(0)\n            self.min_word = sym.sympify(0)\n        elif self.dim == 0:\n            self.max_word = self._expression\n            self.min_word = self._expression\n        else:\n            self.max_word = self.get_vertex(list(range(1, self.dim + 1)), as_word=True)\n            self.min_word = self.get_vertex([], as_word=True)\n\n    def _canonical_form(self):\n        \"\"\"Gets the canonical form of the block by transforming each factor of\n        the form '(1,a)a^r' into 'a^r(1,a)'.\"\"\"\n        for k in range(self.dim, 0, -1):\n            factors = list(sym.sympify(self._x_factors[k]).as_coeff_mul()[1])\n            try:\n                first_factor = factors.pop(0)\n            except IndexError:\n                first_factor = sym.sympify(1)\n            if first_factor.as_base_exp()[0] == self._edges[k - 1]:\n                self._x_factors[k - 1] = self._x_factors[k - 1] * first_factor\n                self._x_factors[k] = sym.Mul(sym.prod(factors))\n\n    def _is_valid_block(self):\n        \"\"\"Check whether a block, already in canonical form, is valid.\"\"\"\n        if self.dim &gt; 0:\n            position_ones = [\n                i for i, s in enumerate(self._x_factors) if s == sym.sympify(1)\n            ]\n            for k in position_ones:\n                if 0 &lt; k &lt; self.dim and self._edges[k] == self._edges[k - 1]:\n                    return False\n        elif self.dim == 0:\n            if self._x_factors[0] == int(0):\n                return False\n        return True\n\n    def _to_chain(self):\n        \"\"\"Convert the block to a Chain object.\n\n        Useful to enable algebraic operations with chains.\n        \"\"\"\n        from InDelsTopo.chain import Chain  # pylint: disable=import-outside-toplevel\n\n        if self.dim &gt;= 0:\n            return Chain(dict_blocks={self: 1})\n        return Chain(dict_blocks={})\n\n    def get_face(self, indices_plus, indices_minus):\n        \"\"\"Return the face \u03c3(indices_plus, indices_minus) of the block \u03c3.\n\n        indices_plus and indices_minus are disjoint subsets of {1, ..., m}, where m is the dimension\n        of the block. They must be given as lists of integers, and may be empty.\n        The output is the block \u03c3(indices_plus, indices_minus), which is either a valid\n        Block of dimension m \u2212 |indices_plus \u222a indices_minus| or the zero Block.\n\n        Args:\n            indices_plus (list of int): Indices in {1, ..., m} of edges (1, a_i) collapsed to a_i.\n            indices_minus (list of int): Indices in {1,..., m} of edges (1, a_i) collapsed to 1.\n\n        Returns:\n            Block: The resulting face block \u03c3(indices_plus, indices_minus) if valid,\n            or the zero Block, otherwise.\n        \"\"\"\n        indices_all = indices_plus + indices_minus\n\n        if len(set(indices_plus).intersection(indices_minus)) &gt; 0:\n            raise ValueError(\"indices_plus and indices_minus must be disjoint\")\n\n        if len(set(indices_all).difference(set(range(1, self.dim + 1)))) &gt; 0:\n            warnings.warn(\n                \"indices_plus or indices_minus contains elements outside of {1, ...\"\n                + str(self.dim)\n                + \"} which have been ignored\"\n            )\n\n        new_x_factors = [self._x_factors[0]]\n        new_edges = []\n        for i in range(1, self.dim + 1):\n            if i in indices_all:\n                current_x_factor = new_x_factors[-1]\n                if i in indices_plus:\n                    x = self._edges[i - 1]\n                else:\n                    x = sym.sympify(1)\n                new_x_factors[-1] = current_x_factor * x * self._x_factors[i]\n            else:\n                new_edges.append(self._edges[i - 1])\n                new_x_factors.append(self._x_factors[i])\n        return Block(\n            x_factors=new_x_factors,\n            edges=new_edges,\n            alphabet=self._alphabet,\n            prod_symbol=self._prod_symbol,\n        )\n\n    def get_upper_facets(self):\n        \"\"\"Return the list of upper facets of the block.\n\n        Each upper facet is obtained by collapsing a single edge (1, a_i) to a_i,\n        for i = 1, ..., m, where m is the dimension of the block.\n\n        Returns:\n            list of Block: A list of Blocks representing the upper facets of the block.\n        \"\"\"\n        upper_facets = [self.get_face([i], []) for i in range(1, self.dim + 1)]\n        return upper_facets\n\n    def get_lower_facets(self):\n        \"\"\"Return the list of lower facets of the block.\n\n        Each lower facet is obtained by collapsing a single edge (1, a_i) to 1,\n        for i = 1, ..., m, where m is the dimension of the block. Invalid blocks\n        are excluded from the output.\n\n        Returns:\n            list of Block: A list of valid Blocks representing the lower facets of the block.\n        \"\"\"\n        lower_facets = [self.get_face([], [i]) for i in range(1, self.dim + 1)]\n        lower_facets = [C for C in lower_facets if C.dim &gt;= 0]\n        return lower_facets\n\n    def get_all_facets(self):\n        \"\"\"Return all facets of the block. Combines both the upper and lower\n        facets of the block.\n\n        Returns:\n            list of Block: A list of Blocks representing all facets of the block.\n        \"\"\"\n        return self.get_upper_facets() + self.get_lower_facets()\n\n    def get_all_faces(self, include_self=False):\n        \"\"\"Return all faces of the block, ordered by dimension.\n\n        Faces are obtained recursively by taking all facets of the block,\n        then all facets of those facets, and so on, down to dimension 0.\n\n        Args:\n            include_self (bool, optional): If True, include the block itself\n                in the returned list. Defaults to False.\n\n        Returns:\n            list of Block: A list of Blocks representing all faces, orted by increasing dimension.\n        \"\"\"\n        if include_self:\n            all_faces = set([self])\n        else:\n            all_faces = set()\n        current_faces = [self]\n        for _ in range(self.dim):\n            current_faces = [\n                facet for c in current_faces for facet in c.get_all_facets()\n            ]\n            all_faces = all_faces.union(current_faces)\n        all_faces = list(all_faces)\n        all_faces.sort(key=lambda x: x.dim)\n        return all_faces\n\n    def get_vertex(self, indices, as_word=True):\n        \"\"\"Return the vertex v_I(\u03c3) of the block determined by a sequence of\n        I = indices.\n\n        The vertex is obtained by collapsing the edges (1,a_i) indexed by 'I' into a_i,\n        and the remaining ones to 1. Returns the vertex as a 0-block,\n        or as a SymPy expression if as_word=True.\n\n        Args:\n            indices (list of int): Indices in {1,..., dim(\u03c3)}\n            as_word (bool, optional): If True, return the vertex as a SymPy\n                expression (word). If False, return the corresponding Block.\n                Defaults to True.\n\n        Returns:\n            Block or SymPy Expression: The resulting vertex as a Block or Sympy expression,\n            depending on `as_word`.\n        \"\"\"\n\n        if len(set(indices).difference(set(range(1, self.dim + 1)))) &gt; 0:\n            warnings.warn(\n                \"indices contains elements outside of {1, ...\"\n                + str(self.dim)\n                + \"} which have been ignored\"\n            )\n\n        indices_minus = list(set(range(1, self.dim + 1)).difference(indices))\n        vertex = self.get_face(indices, indices_minus)\n        if as_word:\n            return vertex.get_expression()\n        return vertex\n\n    def get_all_vertices(self, as_words=True):\n        \"\"\"Return all vertices of the block.\n\n        Args:\n            as_words (bool, optional): If True, return vertices as SymPy expressions\n                (words). If False, return them as Block objects. Defaults to True.\n\n        Returns:\n            list of Block or SymPy Expression: All vertices of the block as Blocks\n            or words, depending on `as_words`.\n        \"\"\"\n        vertices = set()\n        all_indices = _powerset(list(range(1, self.dim + 1)))\n        for indices in all_indices:\n            vertices.add(self.get_vertex(list(indices), as_words))\n        return list(vertices)\n\n    def boundary(self):\n        \"\"\"Computes the boundary of a block.\"\"\"\n        from InDelsTopo.chain import Chain  # pylint: disable=import-outside-toplevel\n\n        result = Chain(dict_blocks={})\n        for i in range(1, self.dim + 1):\n            result += (-1) ** (i + 1) * (\n                self.get_face([i], []) - self.get_face([], [i])\n            )\n        return result\n\n    def _le_recursive(self, other_block):\n        \"\"\"Recursively determine whether this block is a face of another block.\n\n        This internal helper performs the recursive part of the face relation\n        once trivial and extremal cases have been handled. It is not meant to be\n        called directly\u2014use the operator form `A &lt;= B` instead.\n\n        Args:\n            other_block (Block): The block to compare against.\n\n        Returns:\n            bool: True if `self` is a (possibly proper) face of `other_block`,\n            False otherwise.\n        \"\"\"\n        # If same dimension, compare block equality\n        if self.dim == other_block.dim:\n            return self == other_block\n\n        # Compare edges sequences pylint: disable=protected-access\n        if not _is_subsequence(self._edges, other_block._edges):\n            return False\n\n        # Expand and compare the maximal words symbol by symbol\n        word1 = self.max_word\n        word2 = other_block.max_word\n        word1_extended = [\n            symbol\n            for symbol, times in _expand_symp_word(word1)[0]\n            for i in range(times)\n        ]\n        word2_extended = [\n            symbol\n            for symbol, times in _expand_symp_word(word2)[0]\n            for i in range(times)\n        ]\n        if not _is_subsequence(word1_extended, word2_extended):\n            return False\n\n        # Recursive step\n        # If maximal words are equal, descend through upper facets;\n        # otherwise, through lower facets.\n        if word1 == word2:\n            return any(\n                self._le_recursive(facet) for facet in other_block.get_upper_facets()\n            )\n        else:\n            return any(\n                self._le_recursive(facet) for facet in other_block.get_lower_facets()\n            )\n\n    def __le__(self, other_block):\n        \"\"\"\n        Determine whether this Block is a face (\u2264) of another Block.\n\n        A Block `A` is considered less than or equal to another Block `B` if it\n        represents a lower-dimensional face of `B`.\n        \"\"\"\n        # Make sure both are block instances\n        if not isinstance(other_block, Block):\n            return NotImplemented\n\n        # \"Empty\" block is face of all blocks\n        if self.dim == -1:\n            return True\n\n        # Compare dimensions\n        if self.dim &gt; other_block.dim:\n            return False\n\n        # Apply the comparison recursively\n        return self._le_recursive(other_block)\n\n    def __lt__(self, other_block):\n        \"\"\"Return True if this Block is a proper face (&lt;) of another Block.\"\"\"\n        if not isinstance(other_block, Block):\n            return NotImplemented\n        if self.__eq__(other_block):\n            return False\n        return self.__le__(other_block)\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.__init__","title":"<code>__init__(expression=None, alphabet=None, prod_symbol=None, *, x_factors=[int(0)], edges=None)</code>","text":"<p>Initializes a Block.</p> <p>A Block can be either a valid block or the zero block. It is internally represented by a list of factors <code>_x_factors</code> and a list of edge symbols <code>_edges</code>.</p> The block can be initialized from <ul> <li>A string <code>expression</code> in the form \"x_0(1,a_1)x_1...(1,a_m)x_m\"   (handling powers '^' or '*' and product symbols '', '.', or concatenation),</li> <li>Directly from <code>_x_factors</code> and <code>_edges</code> lists,</li> </ul> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>String representation of the block.</p> <code>None</code> <code>_alphabet</code> <code>Alphabet</code> <p>Alphabet defining the letters. Defaults to an empty Alphabet.</p> required <code>_prod_symbol</code> <code>str</code> <p>Product symbol to use ('', '*', or '.'). Inferred from the expression if None.</p> required <code>_x_factors</code> <code>list of SymPy expressions or int</code> <p>Factors x_0, ..., x_k of the block.</p> required <code>_edges</code> <code>list of SymPy symbols</code> <p>Edge symbols a_1, ..., a_k corresponding to the block.</p> required Source code in <code>InDelsTopo/block.py</code> <pre><code>def __init__(\n    self,\n    expression=None,\n    alphabet=None,\n    prod_symbol=None,\n    *,\n    x_factors=[int(0)],\n    edges=None,\n):\n    \"\"\"Initializes a Block.\n\n    A Block can be either a valid block or the zero block. It is internally\n    represented by a list of factors `_x_factors` and a list of edge symbols\n    `_edges`.\n\n    The block can be initialized from:\n        - A string `expression` in the form \"x_0(1,a_1)x_1...(1,a_m)x_m\"\n          (handling powers '^' or '**' and product symbols '*', '.', or concatenation),\n        - Directly from `_x_factors` and `_edges` lists,\n\n    Args:\n        expression (str, optional): String representation of the block.\n        _alphabet (Alphabet, optional): Alphabet defining the letters.\n            Defaults to an empty Alphabet.\n        _prod_symbol (str, optional): Product symbol to use ('', '*', or '.').\n            Inferred from the expression if None.\n        _x_factors (list of SymPy expressions or int, optional):\n            Factors x_0, ..., x_k of the block.\n        _edges (list of SymPy symbols, optional): Edge symbols a_1, ..., a_k\n            corresponding to the block.\n    \"\"\"\n    super().__init__()  # initialize base class attributes\n    x_factors = [int(0)] if x_factors is None else x_factors\n    edges = [] if edges is None else edges\n    alphabet = Alphabet([]) if alphabet is None else alphabet\n\n    # Use expression if provided\n    if isinstance(expression, str):\n        if expression == \"1\":\n            x_factors = [int(1)]\n            edges = []\n            prod_symbol = \"\"\n        else:\n            x_factors, edges, alphabet, prod_symbol = _block_str_constructor(\n                expression, alphabet, prod_symbol\n            )\n\n    if len(x_factors) == 0:\n        self._x_factors = [int(0)]\n        self._edges = []\n        self.dim = -1\n\n    elif len(x_factors) - len(edges) != 1:\n        raise Exception(\"x_factors must be one unit longer than edges.\")\n\n    # Set attributes\n    self._x_factors = x_factors\n    self._edges = edges\n    self.dim = len(edges)\n    self._prod_symbol = prod_symbol\n    self._alphabet = alphabet\n\n    # Get canonical form\n    self._canonical_form()\n\n    # Check is a valid block\n    if not self._is_valid_block():\n        self._x_factors = [int(0)]\n        self._edges = []\n        self.dim = -1\n\n    # Expression\n    edges = [self._alphabet.get(str(a), 1) for a in self._edges] + [sym.sympify(1)]\n    self._expression = sym.prod(\n        [val for pair in zip(self._x_factors, edges) for val in pair]\n    )\n\n    # Maximal and minimal words\n    if self.dim &lt; 0:\n        self.max_word = sym.sympify(0)\n        self.min_word = sym.sympify(0)\n    elif self.dim == 0:\n        self.max_word = self._expression\n        self.min_word = self._expression\n    else:\n        self.max_word = self.get_vertex(list(range(1, self.dim + 1)), as_word=True)\n        self.min_word = self.get_vertex([], as_word=True)\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.__le__","title":"<code>__le__(other_block)</code>","text":"<p>Determine whether this Block is a face (\u2264) of another Block.</p> <p>A Block <code>A</code> is considered less than or equal to another Block <code>B</code> if it represents a lower-dimensional face of <code>B</code>.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def __le__(self, other_block):\n    \"\"\"\n    Determine whether this Block is a face (\u2264) of another Block.\n\n    A Block `A` is considered less than or equal to another Block `B` if it\n    represents a lower-dimensional face of `B`.\n    \"\"\"\n    # Make sure both are block instances\n    if not isinstance(other_block, Block):\n        return NotImplemented\n\n    # \"Empty\" block is face of all blocks\n    if self.dim == -1:\n        return True\n\n    # Compare dimensions\n    if self.dim &gt; other_block.dim:\n        return False\n\n    # Apply the comparison recursively\n    return self._le_recursive(other_block)\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.__lt__","title":"<code>__lt__(other_block)</code>","text":"<p>Return True if this Block is a proper face (&lt;) of another Block.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def __lt__(self, other_block):\n    \"\"\"Return True if this Block is a proper face (&lt;) of another Block.\"\"\"\n    if not isinstance(other_block, Block):\n        return NotImplemented\n    if self.__eq__(other_block):\n        return False\n    return self.__le__(other_block)\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.boundary","title":"<code>boundary()</code>","text":"<p>Computes the boundary of a block.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def boundary(self):\n    \"\"\"Computes the boundary of a block.\"\"\"\n    from InDelsTopo.chain import Chain  # pylint: disable=import-outside-toplevel\n\n    result = Chain(dict_blocks={})\n    for i in range(1, self.dim + 1):\n        result += (-1) ** (i + 1) * (\n            self.get_face([i], []) - self.get_face([], [i])\n        )\n    return result\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.get_all_faces","title":"<code>get_all_faces(include_self=False)</code>","text":"<p>Return all faces of the block, ordered by dimension.</p> <p>Faces are obtained recursively by taking all facets of the block, then all facets of those facets, and so on, down to dimension 0.</p> <p>Parameters:</p> Name Type Description Default <code>include_self</code> <code>bool</code> <p>If True, include the block itself in the returned list. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>list of Block: A list of Blocks representing all faces, orted by increasing dimension.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def get_all_faces(self, include_self=False):\n    \"\"\"Return all faces of the block, ordered by dimension.\n\n    Faces are obtained recursively by taking all facets of the block,\n    then all facets of those facets, and so on, down to dimension 0.\n\n    Args:\n        include_self (bool, optional): If True, include the block itself\n            in the returned list. Defaults to False.\n\n    Returns:\n        list of Block: A list of Blocks representing all faces, orted by increasing dimension.\n    \"\"\"\n    if include_self:\n        all_faces = set([self])\n    else:\n        all_faces = set()\n    current_faces = [self]\n    for _ in range(self.dim):\n        current_faces = [\n            facet for c in current_faces for facet in c.get_all_facets()\n        ]\n        all_faces = all_faces.union(current_faces)\n    all_faces = list(all_faces)\n    all_faces.sort(key=lambda x: x.dim)\n    return all_faces\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.get_all_facets","title":"<code>get_all_facets()</code>","text":"<p>Return all facets of the block. Combines both the upper and lower facets of the block.</p> <p>Returns:</p> Type Description <p>list of Block: A list of Blocks representing all facets of the block.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def get_all_facets(self):\n    \"\"\"Return all facets of the block. Combines both the upper and lower\n    facets of the block.\n\n    Returns:\n        list of Block: A list of Blocks representing all facets of the block.\n    \"\"\"\n    return self.get_upper_facets() + self.get_lower_facets()\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.get_all_vertices","title":"<code>get_all_vertices(as_words=True)</code>","text":"<p>Return all vertices of the block.</p> <p>Parameters:</p> Name Type Description Default <code>as_words</code> <code>bool</code> <p>If True, return vertices as SymPy expressions (words). If False, return them as Block objects. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>list of Block or SymPy Expression: All vertices of the block as Blocks</p> <p>or words, depending on <code>as_words</code>.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def get_all_vertices(self, as_words=True):\n    \"\"\"Return all vertices of the block.\n\n    Args:\n        as_words (bool, optional): If True, return vertices as SymPy expressions\n            (words). If False, return them as Block objects. Defaults to True.\n\n    Returns:\n        list of Block or SymPy Expression: All vertices of the block as Blocks\n        or words, depending on `as_words`.\n    \"\"\"\n    vertices = set()\n    all_indices = _powerset(list(range(1, self.dim + 1)))\n    for indices in all_indices:\n        vertices.add(self.get_vertex(list(indices), as_words))\n    return list(vertices)\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.get_face","title":"<code>get_face(indices_plus, indices_minus)</code>","text":"<p>Return the face \u03c3(indices_plus, indices_minus) of the block \u03c3.</p> <p>indices_plus and indices_minus are disjoint subsets of {1, ..., m}, where m is the dimension of the block. They must be given as lists of integers, and may be empty. The output is the block \u03c3(indices_plus, indices_minus), which is either a valid Block of dimension m \u2212 |indices_plus \u222a indices_minus| or the zero Block.</p> <p>Parameters:</p> Name Type Description Default <code>indices_plus</code> <code>list of int</code> <p>Indices in {1, ..., m} of edges (1, a_i) collapsed to a_i.</p> required <code>indices_minus</code> <code>list of int</code> <p>Indices in {1,..., m} of edges (1, a_i) collapsed to 1.</p> required <p>Returns:</p> Name Type Description <code>Block</code> <p>The resulting face block \u03c3(indices_plus, indices_minus) if valid,</p> <p>or the zero Block, otherwise.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def get_face(self, indices_plus, indices_minus):\n    \"\"\"Return the face \u03c3(indices_plus, indices_minus) of the block \u03c3.\n\n    indices_plus and indices_minus are disjoint subsets of {1, ..., m}, where m is the dimension\n    of the block. They must be given as lists of integers, and may be empty.\n    The output is the block \u03c3(indices_plus, indices_minus), which is either a valid\n    Block of dimension m \u2212 |indices_plus \u222a indices_minus| or the zero Block.\n\n    Args:\n        indices_plus (list of int): Indices in {1, ..., m} of edges (1, a_i) collapsed to a_i.\n        indices_minus (list of int): Indices in {1,..., m} of edges (1, a_i) collapsed to 1.\n\n    Returns:\n        Block: The resulting face block \u03c3(indices_plus, indices_minus) if valid,\n        or the zero Block, otherwise.\n    \"\"\"\n    indices_all = indices_plus + indices_minus\n\n    if len(set(indices_plus).intersection(indices_minus)) &gt; 0:\n        raise ValueError(\"indices_plus and indices_minus must be disjoint\")\n\n    if len(set(indices_all).difference(set(range(1, self.dim + 1)))) &gt; 0:\n        warnings.warn(\n            \"indices_plus or indices_minus contains elements outside of {1, ...\"\n            + str(self.dim)\n            + \"} which have been ignored\"\n        )\n\n    new_x_factors = [self._x_factors[0]]\n    new_edges = []\n    for i in range(1, self.dim + 1):\n        if i in indices_all:\n            current_x_factor = new_x_factors[-1]\n            if i in indices_plus:\n                x = self._edges[i - 1]\n            else:\n                x = sym.sympify(1)\n            new_x_factors[-1] = current_x_factor * x * self._x_factors[i]\n        else:\n            new_edges.append(self._edges[i - 1])\n            new_x_factors.append(self._x_factors[i])\n    return Block(\n        x_factors=new_x_factors,\n        edges=new_edges,\n        alphabet=self._alphabet,\n        prod_symbol=self._prod_symbol,\n    )\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.get_lower_facets","title":"<code>get_lower_facets()</code>","text":"<p>Return the list of lower facets of the block.</p> <p>Each lower facet is obtained by collapsing a single edge (1, a_i) to 1, for i = 1, ..., m, where m is the dimension of the block. Invalid blocks are excluded from the output.</p> <p>Returns:</p> Type Description <p>list of Block: A list of valid Blocks representing the lower facets of the block.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def get_lower_facets(self):\n    \"\"\"Return the list of lower facets of the block.\n\n    Each lower facet is obtained by collapsing a single edge (1, a_i) to 1,\n    for i = 1, ..., m, where m is the dimension of the block. Invalid blocks\n    are excluded from the output.\n\n    Returns:\n        list of Block: A list of valid Blocks representing the lower facets of the block.\n    \"\"\"\n    lower_facets = [self.get_face([], [i]) for i in range(1, self.dim + 1)]\n    lower_facets = [C for C in lower_facets if C.dim &gt;= 0]\n    return lower_facets\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.get_upper_facets","title":"<code>get_upper_facets()</code>","text":"<p>Return the list of upper facets of the block.</p> <p>Each upper facet is obtained by collapsing a single edge (1, a_i) to a_i, for i = 1, ..., m, where m is the dimension of the block.</p> <p>Returns:</p> Type Description <p>list of Block: A list of Blocks representing the upper facets of the block.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def get_upper_facets(self):\n    \"\"\"Return the list of upper facets of the block.\n\n    Each upper facet is obtained by collapsing a single edge (1, a_i) to a_i,\n    for i = 1, ..., m, where m is the dimension of the block.\n\n    Returns:\n        list of Block: A list of Blocks representing the upper facets of the block.\n    \"\"\"\n    upper_facets = [self.get_face([i], []) for i in range(1, self.dim + 1)]\n    return upper_facets\n</code></pre>"},{"location":"reference/#InDelsTopo.Block.get_vertex","title":"<code>get_vertex(indices, as_word=True)</code>","text":"<p>Return the vertex v_I(\u03c3) of the block determined by a sequence of I = indices.</p> <p>The vertex is obtained by collapsing the edges (1,a_i) indexed by 'I' into a_i, and the remaining ones to 1. Returns the vertex as a 0-block, or as a SymPy expression if as_word=True.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>list of int</code> <p>Indices in {1,..., dim(\u03c3)}</p> required <code>as_word</code> <code>bool</code> <p>If True, return the vertex as a SymPy expression (word). If False, return the corresponding Block. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Block or SymPy Expression: The resulting vertex as a Block or Sympy expression,</p> <p>depending on <code>as_word</code>.</p> Source code in <code>InDelsTopo/block.py</code> <pre><code>def get_vertex(self, indices, as_word=True):\n    \"\"\"Return the vertex v_I(\u03c3) of the block determined by a sequence of\n    I = indices.\n\n    The vertex is obtained by collapsing the edges (1,a_i) indexed by 'I' into a_i,\n    and the remaining ones to 1. Returns the vertex as a 0-block,\n    or as a SymPy expression if as_word=True.\n\n    Args:\n        indices (list of int): Indices in {1,..., dim(\u03c3)}\n        as_word (bool, optional): If True, return the vertex as a SymPy\n            expression (word). If False, return the corresponding Block.\n            Defaults to True.\n\n    Returns:\n        Block or SymPy Expression: The resulting vertex as a Block or Sympy expression,\n        depending on `as_word`.\n    \"\"\"\n\n    if len(set(indices).difference(set(range(1, self.dim + 1)))) &gt; 0:\n        warnings.warn(\n            \"indices contains elements outside of {1, ...\"\n            + str(self.dim)\n            + \"} which have been ignored\"\n        )\n\n    indices_minus = list(set(range(1, self.dim + 1)).difference(indices))\n    vertex = self.get_face(indices, indices_minus)\n    if as_word:\n        return vertex.get_expression()\n    return vertex\n</code></pre>"},{"location":"reference/#InDelsTopo.Chain","title":"<code>Chain</code>","text":"<p>               Bases: <code>ChainBlockBase</code></p> <p>Represents a chain in the Insertion Chain Complex: a linear combination of valid blocks with integer coefficients.</p> <p>It can be initialized from a string expression, a list of coefficients and blocks, or a dictionary mapping blocks to coefficients.</p> <p>Supports algebraic operations (addition, subtraction, and scalar multiplication), equality checking, string and LaTeX representations, and computation of the boundary.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Maximum dimension among the blocks in the chain, or -1 if empty.</p> Internal_attributes <p>_expression(SymPy expression): represents the chain as a sum of block expressions. _alphabet (Alphabet): The Alphabet instance used for all blocks in the chain. _dict_blocks (dict): (for internal use only)     dictionary mapping Block objects to integer coefficients. _prod_symbol (str): Either '', '*', or '.'.</p> Source code in <code>InDelsTopo/chain.py</code> <pre><code>class Chain(ChainBlockBase):\n    \"\"\"\n    Represents a chain in the Insertion Chain Complex:\n    a linear combination of valid blocks with integer coefficients.\n\n    It can be initialized from a string expression, a list of coefficients and blocks,\n    or a dictionary mapping blocks to coefficients.\n\n    Supports algebraic operations (addition, subtraction, and scalar multiplication),\n    equality checking, string and LaTeX representations, and computation of the boundary.\n\n    Attributes:\n        dim (int): Maximum dimension among the blocks in the chain, or -1 if empty.\n\n    Internal_attributes:\n        _expression(SymPy expression): represents the chain as a sum of block expressions.\n        _alphabet (Alphabet): The Alphabet instance used for all blocks in the chain.\n        _dict_blocks (dict): (for internal use only)\n            dictionary mapping Block objects to integer coefficients.\n        _prod_symbol (str): Either '', '*', or '.'.\n    \"\"\"\n\n    def __init__(\n        self,\n        expression=None,\n        alphabet=None,\n        prod_symbol=None,\n        *,\n        list_coeffs=None,\n        list_blocks=None,\n        dict_blocks=None,\n    ):\n        \"\"\"\n        Represents a chain in the Insertion Chain Complex:\n        a linear combination of valid blocks with integer coefficients.\n\n        Each term can include an integer coefficient followed by a block, e.g.,\n        '2abc(1,a)b^ac(1,b)ac - (1,c)(1,a)b^2'.\n\n        The class can be initialized from:\n            - a string expression (preferred way for end users),\n            - a list of coefficients and blocks, or\n            - a dictionary mapping blocks to coefficients.\n\n        Args:\n            expression (str, optional): Chain written as a string of blocks. This is the\n                preferred way for end users to construct a chain.\n            alphabet (Alphabet, optional): Alphabet object defining the set of letters.\n                If set to None, a new empty alphabet is created.\n            prod_symbol (str, optional): Product symbol to use in blocks.\n                Must be one of {'', '*', '.'}. If None, it is inferred from the expression:\n                '*' if '*' appears, '.' if '.' appears, or '' otherwise.\n            list_coeffs (list of int, optional): Integer coefficients of the chain terms.\n                Must be provided together with `list_blocks`.\n                Ignored if `expression` or `dict_blocks` is given.\n            list_blocks (list of Block, optional): Block objects corresponding to the coefficients\n                in `list_coeffs`. Ignored if `expression` or `dict_blocks` is given.\n            dict_blocks (dict, optional): Dictionary mapping Block objects to integer coefficients.\n                If provided, it takes precedence over `expression`,`list_coeffs`, and `list_blocks`.\n        \"\"\"\n        super().__init__()\n        alphabet = Alphabet([]) if alphabet is None else alphabet\n\n        # If dict_blocks provided use that one\n        if dict_blocks is not None:\n            # Check all keys are instances of Block\n            if not all(isinstance(b, Block) for b in dict_blocks.keys()):\n                raise TypeError(\"All keys of dict_blocks must be instances of Block\")\n\n            # Check all values are integers\n            if not all(isinstance(c, int) for c in dict_blocks.values()):\n                raise TypeError(\"All values of dict_blocks must be integers\")\n\n            self._dict_blocks = dict_blocks\n            self._alphabet = _combine_blocks_alphabet(dict_blocks.keys(), alphabet)\n\n            # Use provided prod_symbol or use a suitable: concatenation for symbols of\n            # length 1, \".\" otherwise\n            if prod_symbol in [\"\", \".\", \"*\"]:\n                self._prod_symbol = prod_symbol\n            elif (\n                max([len(symbol) for symbol in self._alphabet.letters_str], default=1)\n                &gt; 1\n            ):\n                self._prod_symbol = \".\"\n            else:\n                self._prod_symbol = \"\"\n\n        # Otherwise, if expression is present, or list_coeff, list_blocks are\n        # present, use that.\n        else:\n            if isinstance(expression, str):\n                list_coeffs, list_blocks, alphabet, prod_symbol = (\n                    _chain_str_constructor(expression, alphabet, prod_symbol)\n                )\n                self._alphabet = alphabet\n                self._prod_symbol = prod_symbol\n\n            else:  # Check list_coeffs and list_blocks are valid and create alphabet and prod_symbol\n\n                # Check list_coeffs and list_blocks have same length\n                if len(list_coeffs) != len(list_blocks):\n                    raise ValueError(\n                        \"list_coeffs and list_blocks must have the same length\"\n                    )\n\n                # Check all elements in list_blocks are instances of Block\n                if not all(isinstance(b, Block) for b in list_blocks):\n                    raise TypeError(\n                        \"All elements of list_blocks must be instances of Block\"\n                    )\n\n                # Check all elements in list_coeffs are integers\n                if not all(isinstance(c, int) for c in list_coeffs):\n                    raise TypeError(\"All elements of list_coeffs must be integers\")\n\n                # Set alphabet\n\n                self._alphabet = _combine_blocks_alphabet(dict_blocks.keys(), alphabet)\n                # Use provided prod_symbol or use a suitable: concatenation for symbols of\n                # length 1, \".\" otherwise\n                if prod_symbol in [\"\", \".\", \"*\"]:\n                    self._prod_symbol = prod_symbol\n                elif (\n                    max(\n                        [len(symbol) for symbol in self._alphabet.letters_str],\n                        default=1,\n                    )\n                    &gt; 1\n                ):\n                    self._prod_symbol = \".\"\n                else:\n                    self._prod_symbol = \"\"\n\n            # Create dictionary\n            self._dict_blocks = {}\n            for i, block in enumerate(list_blocks):\n                if block not in self._dict_blocks:\n                    self._dict_blocks[block] = list_coeffs[i]\n                else:\n                    self._dict_blocks[block] += list_coeffs[i]\n\n        # Clean dict_blocks\n        _clean_dictionary_blocks(self._dict_blocks)\n\n        # Set up attributes\n        self._create_expression()\n        self.dim = max([B.dim for B in self._dict_blocks] + [-1])\n\n    def _create_expression(self):\n        \"\"\"Build the SymPy expression from the chain's blocks and\n        coefficients.\"\"\"\n        # Create expression\n        self._expression = int(0) + sum(\n            [\n                int(self._dict_blocks[block]) * block.get_expression()\n                for block in self._dict_blocks\n            ]\n        )\n\n    def __add__(self, other):\n        new_dict = copy.deepcopy(self._to_chain()._dict_blocks)\n        other = other._to_chain()\n        for block in other._dict_blocks:\n            if block in new_dict:\n                new_dict[block] += other._dict_blocks[block]\n            else:\n                new_dict[block] = other._dict_blocks[block]\n        _clean_dictionary_blocks(new_dict)\n        return Chain(dict_blocks=new_dict)\n\n    def __rmul__(self, coeff):\n        dict_blocks = self._to_chain()._dict_blocks.copy()\n        if coeff != 0:\n            new_dict = {c: coeff * dict_blocks[c] for c in dict_blocks}\n        else:\n            new_dict = {}\n        return Chain(\n            dict_blocks=new_dict, alphabet=self._alphabet, prod_symbol=self._prod_symbol\n        )\n\n    def boundary(self):\n        \"\"\"Return the boundary of the chain as a new Chain.\"\"\"\n        new_dict = {}\n        for block in self._dict_blocks:\n            coeff = self._dict_blocks[block]\n            dict_boundary = block.boundary().get_dict_blocks()\n            for new_block in dict_boundary:\n                if new_block in new_dict:\n                    new_dict[new_block] += coeff * dict_boundary[new_block]\n                else:\n                    new_dict[new_block] = coeff * dict_boundary[new_block]\n\n        _clean_dictionary_blocks(new_dict)\n        return Chain(\n            dict_blocks=new_dict, alphabet=self._alphabet, prod_symbol=self._prod_symbol\n        )\n\n    def get_dict_blocks(self):\n        \"\"\"Return a copy of the internal blocks dictionary.\"\"\"\n        return self._dict_blocks.copy()\n</code></pre>"},{"location":"reference/#InDelsTopo.Chain.__init__","title":"<code>__init__(expression=None, alphabet=None, prod_symbol=None, *, list_coeffs=None, list_blocks=None, dict_blocks=None)</code>","text":"<p>Represents a chain in the Insertion Chain Complex: a linear combination of valid blocks with integer coefficients.</p> <p>Each term can include an integer coefficient followed by a block, e.g., '2abc(1,a)b^ac(1,b)ac - (1,c)(1,a)b^2'.</p> The class can be initialized from <ul> <li>a string expression (preferred way for end users),</li> <li>a list of coefficients and blocks, or</li> <li>a dictionary mapping blocks to coefficients.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>Chain written as a string of blocks. This is the preferred way for end users to construct a chain.</p> <code>None</code> <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object defining the set of letters. If set to None, a new empty alphabet is created.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>Product symbol to use in blocks. Must be one of {'', '', '.'}. If None, it is inferred from the expression: '' if '*' appears, '.' if '.' appears, or '' otherwise.</p> <code>None</code> <code>list_coeffs</code> <code>list of int</code> <p>Integer coefficients of the chain terms. Must be provided together with <code>list_blocks</code>. Ignored if <code>expression</code> or <code>dict_blocks</code> is given.</p> <code>None</code> <code>list_blocks</code> <code>list of Block</code> <p>Block objects corresponding to the coefficients in <code>list_coeffs</code>. Ignored if <code>expression</code> or <code>dict_blocks</code> is given.</p> <code>None</code> <code>dict_blocks</code> <code>dict</code> <p>Dictionary mapping Block objects to integer coefficients. If provided, it takes precedence over <code>expression</code>,<code>list_coeffs</code>, and <code>list_blocks</code>.</p> <code>None</code> Source code in <code>InDelsTopo/chain.py</code> <pre><code>def __init__(\n    self,\n    expression=None,\n    alphabet=None,\n    prod_symbol=None,\n    *,\n    list_coeffs=None,\n    list_blocks=None,\n    dict_blocks=None,\n):\n    \"\"\"\n    Represents a chain in the Insertion Chain Complex:\n    a linear combination of valid blocks with integer coefficients.\n\n    Each term can include an integer coefficient followed by a block, e.g.,\n    '2abc(1,a)b^ac(1,b)ac - (1,c)(1,a)b^2'.\n\n    The class can be initialized from:\n        - a string expression (preferred way for end users),\n        - a list of coefficients and blocks, or\n        - a dictionary mapping blocks to coefficients.\n\n    Args:\n        expression (str, optional): Chain written as a string of blocks. This is the\n            preferred way for end users to construct a chain.\n        alphabet (Alphabet, optional): Alphabet object defining the set of letters.\n            If set to None, a new empty alphabet is created.\n        prod_symbol (str, optional): Product symbol to use in blocks.\n            Must be one of {'', '*', '.'}. If None, it is inferred from the expression:\n            '*' if '*' appears, '.' if '.' appears, or '' otherwise.\n        list_coeffs (list of int, optional): Integer coefficients of the chain terms.\n            Must be provided together with `list_blocks`.\n            Ignored if `expression` or `dict_blocks` is given.\n        list_blocks (list of Block, optional): Block objects corresponding to the coefficients\n            in `list_coeffs`. Ignored if `expression` or `dict_blocks` is given.\n        dict_blocks (dict, optional): Dictionary mapping Block objects to integer coefficients.\n            If provided, it takes precedence over `expression`,`list_coeffs`, and `list_blocks`.\n    \"\"\"\n    super().__init__()\n    alphabet = Alphabet([]) if alphabet is None else alphabet\n\n    # If dict_blocks provided use that one\n    if dict_blocks is not None:\n        # Check all keys are instances of Block\n        if not all(isinstance(b, Block) for b in dict_blocks.keys()):\n            raise TypeError(\"All keys of dict_blocks must be instances of Block\")\n\n        # Check all values are integers\n        if not all(isinstance(c, int) for c in dict_blocks.values()):\n            raise TypeError(\"All values of dict_blocks must be integers\")\n\n        self._dict_blocks = dict_blocks\n        self._alphabet = _combine_blocks_alphabet(dict_blocks.keys(), alphabet)\n\n        # Use provided prod_symbol or use a suitable: concatenation for symbols of\n        # length 1, \".\" otherwise\n        if prod_symbol in [\"\", \".\", \"*\"]:\n            self._prod_symbol = prod_symbol\n        elif (\n            max([len(symbol) for symbol in self._alphabet.letters_str], default=1)\n            &gt; 1\n        ):\n            self._prod_symbol = \".\"\n        else:\n            self._prod_symbol = \"\"\n\n    # Otherwise, if expression is present, or list_coeff, list_blocks are\n    # present, use that.\n    else:\n        if isinstance(expression, str):\n            list_coeffs, list_blocks, alphabet, prod_symbol = (\n                _chain_str_constructor(expression, alphabet, prod_symbol)\n            )\n            self._alphabet = alphabet\n            self._prod_symbol = prod_symbol\n\n        else:  # Check list_coeffs and list_blocks are valid and create alphabet and prod_symbol\n\n            # Check list_coeffs and list_blocks have same length\n            if len(list_coeffs) != len(list_blocks):\n                raise ValueError(\n                    \"list_coeffs and list_blocks must have the same length\"\n                )\n\n            # Check all elements in list_blocks are instances of Block\n            if not all(isinstance(b, Block) for b in list_blocks):\n                raise TypeError(\n                    \"All elements of list_blocks must be instances of Block\"\n                )\n\n            # Check all elements in list_coeffs are integers\n            if not all(isinstance(c, int) for c in list_coeffs):\n                raise TypeError(\"All elements of list_coeffs must be integers\")\n\n            # Set alphabet\n\n            self._alphabet = _combine_blocks_alphabet(dict_blocks.keys(), alphabet)\n            # Use provided prod_symbol or use a suitable: concatenation for symbols of\n            # length 1, \".\" otherwise\n            if prod_symbol in [\"\", \".\", \"*\"]:\n                self._prod_symbol = prod_symbol\n            elif (\n                max(\n                    [len(symbol) for symbol in self._alphabet.letters_str],\n                    default=1,\n                )\n                &gt; 1\n            ):\n                self._prod_symbol = \".\"\n            else:\n                self._prod_symbol = \"\"\n\n        # Create dictionary\n        self._dict_blocks = {}\n        for i, block in enumerate(list_blocks):\n            if block not in self._dict_blocks:\n                self._dict_blocks[block] = list_coeffs[i]\n            else:\n                self._dict_blocks[block] += list_coeffs[i]\n\n    # Clean dict_blocks\n    _clean_dictionary_blocks(self._dict_blocks)\n\n    # Set up attributes\n    self._create_expression()\n    self.dim = max([B.dim for B in self._dict_blocks] + [-1])\n</code></pre>"},{"location":"reference/#InDelsTopo.Chain.boundary","title":"<code>boundary()</code>","text":"<p>Return the boundary of the chain as a new Chain.</p> Source code in <code>InDelsTopo/chain.py</code> <pre><code>def boundary(self):\n    \"\"\"Return the boundary of the chain as a new Chain.\"\"\"\n    new_dict = {}\n    for block in self._dict_blocks:\n        coeff = self._dict_blocks[block]\n        dict_boundary = block.boundary().get_dict_blocks()\n        for new_block in dict_boundary:\n            if new_block in new_dict:\n                new_dict[new_block] += coeff * dict_boundary[new_block]\n            else:\n                new_dict[new_block] = coeff * dict_boundary[new_block]\n\n    _clean_dictionary_blocks(new_dict)\n    return Chain(\n        dict_blocks=new_dict, alphabet=self._alphabet, prod_symbol=self._prod_symbol\n    )\n</code></pre>"},{"location":"reference/#InDelsTopo.Chain.get_dict_blocks","title":"<code>get_dict_blocks()</code>","text":"<p>Return a copy of the internal blocks dictionary.</p> Source code in <code>InDelsTopo/chain.py</code> <pre><code>def get_dict_blocks(self):\n    \"\"\"Return a copy of the internal blocks dictionary.\"\"\"\n    return self._dict_blocks.copy()\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex","title":"<code>Complex</code>","text":"<p>Represents an Insertion Chain Complex C[W] for a set of words W.</p> <p>The class stores the blocks of the complex in each dimension and provides methods to compute topological invariants such as the Euler characteristic and Betti numbers (over Z_2 or Z when using a SageMath kernel). It also supports graphical visualization of the complex in low dimensions.</p> <p>The k-dimensional blocks can be accessed via indexing syntax: <code>K[k]</code> returns the list of k-blocks.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Maximum dimension of the complex.</p> <code>complex_dict</code> <code>dict[int, list[Block]]</code> <p>Maps each dimension to its corresponding list of blocks.</p> <code>height</code> <code>float | None</code> <p>Height value associated with the complex.</p> Internal attributes <p>_alphabet (Alphabet): Alphabet object containing all symbols used in W. _prod_symbol (str): Product symbol used in the blocks. _positions_dict (dict | None): Stores vertex positions for graphical visualization.</p> Notes <ul> <li>This class can be used to build and analyze Insertion Chain Complexes directly,   or as a sublevel complex of a filtration.</li> <li>Homology computations over Z require SageMath; otherwise, only Z_2 computations   are available using SciPy.</li> <li>It initializes as an empty complex. It can be made into the insertion chain complex     of a set of words <code>W</code> by using the method <code>compute_d_skeleton(W)</code>.</li> <li>Blocks can be added or removed by using the methods <code>add_blocks</code> and <code>remove_blocks</code>.</li> </ul> Example <p>W = [\"ab\", \"aab\", \"abb\"] K = Complex() # Creates an empty complex K.compute_d_skeleton(W) # makes K = C[W] K[1]  # Access 1-dimensional blocks [a(1,a)b, ab(1,b)]</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>class Complex:\n    \"\"\"\n    Represents an Insertion Chain Complex C[W] for a set of words W.\n\n    The class stores the blocks of the complex in each dimension and provides\n    methods to compute topological invariants such as the Euler characteristic\n    and Betti numbers (over Z_2 or Z when using a SageMath kernel). It also\n    supports graphical visualization of the complex in low dimensions.\n\n    The k-dimensional blocks can be accessed via indexing syntax:\n    `K[k]` returns the list of k-blocks.\n\n    Attributes:\n        dim (int): Maximum dimension of the complex.\n        complex_dict (dict[int, list[Block]]): Maps each dimension to its corresponding\n            list of blocks.\n        height (float | None): Height value associated with the complex.\n\n    Internal attributes:\n        _alphabet (Alphabet): Alphabet object containing all symbols used in W.\n        _prod_symbol (str): Product symbol used in the blocks.\n        _positions_dict (dict | None): Stores vertex positions for graphical visualization.\n\n    Notes:\n        - This class can be used to build and analyze Insertion Chain Complexes directly,\n          or as a sublevel complex of a filtration.\n        - Homology computations over Z require SageMath; otherwise, only Z_2 computations\n          are available using SciPy.\n        - It initializes as an empty complex. It can be made into the insertion chain complex\n            of a set of words `W` by using the method `compute_d_skeleton(W)`.\n        - Blocks can be added or removed by using the methods `add_blocks` and `remove_blocks`.\n\n\n    Example:\n        &gt;&gt;&gt; W = [\"ab\", \"aab\", \"abb\"]\n        &gt;&gt;&gt; K = Complex() # Creates an empty complex\n        &gt;&gt;&gt; K.compute_d_skeleton(W) # makes K = C[W]\n        &gt;&gt;&gt; K[1]  # Access 1-dimensional blocks\n        [a(1,a)b, ab(1,b)]\n    \"\"\"\n\n    def __init__(\n        self, alphabet=None, prod_symbol=None, *, complex_dict=None, height=None\n    ):\n        \"\"\"\n        Initialize an Insertion Chain Complex.\n\n        This constructor creates a new complex object, which can either start empty\n        (with no blocks) or be initialized from a given dictionary of blocks.\n        Optionally, the complex can store a height value, useful when representing\n        a level in a filtration.\n\n        Args:\n            alphabet (Alphabet | None, optional): The alphabet containing all symbols\n                to be used. Defaults to None.\n            prod_symbol (str | None, optional): Product symbol used for block construction,\n                Must be one of {'', '*', '.'}. If None, it is inferred from the expression:\n                set to '*' if '*' appears, to '.' if '.' appears, or to '' (concatenation)\n                otherwise.\n            complex_dict (dict[int, list[Block]] | None, optional): Mapping from\n                dimension `d` to the list of d-dimensional blocks. If provided, it\n                initializes the complex structure directly. Defaults to None.\n            height (float | None, optional): Height value associated with the complex,\n                used when part of a filtration. Defaults to None.\n        \"\"\"\n        self._alphabet = alphabet\n        self._prod_symbol = prod_symbol\n        self.dim = -1\n        self.complex_dict = {}\n        self.height = None\n        self._positions_dict = None\n\n        if not complex_dict is None:\n            self.dim = max(complex_dict.keys(), default=-1)\n            self.complex_dict = complex_dict\n            self.height = height\n\n    def compute_d_skeleton(\n        self,\n        W,\n        height=None,\n        max_dim=10,\n        alphabet=None,\n        prod_symbol=None,\n        check_duplicates=True,\n        already_blocks=False,\n        verbose=False,\n    ):\n        \"\"\"\n        Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W].\n        This method replaces any existing data in the Complex with a new complex supported on `W`.\n\n        This method constructs all valid blocks up to the specified maximum dimension (`max_dim`)\n        for a given set of words `W`. It begins by computing the 0- and 1-skeletons (vertices and edges),\n        then iteratively extends to higher dimensions.\n\n        It updates the internal `complex_dict` to the blocks supported on `W`.\n\n        Args:\n            W (list of str or Block): List of words (or blocks, if `already_blocks=True`)\n                forming the base of the complex.\n            height (float, optional): Height value associated with the complex,\n                used when part of a filtration. Defaults to None.\n            max_dim (int, optional): Maximum dimension of the skeleton to compute. Defaults to 10.\n            alphabet (Alphabet, optional): Alphabet object used together with the internal\n                `self._alphabet` and any letters inferred from `W`. If provided, its symbols\n                are merged with `self._alphabet`; otherwise, the new symbols are inferred entirely\n                from the given words.\n            prod_symbol (str, optional): Product symbol for block construction ('*', '.', or '').\n                If None, inferred automatically.\n            check_duplicates (bool, optional): Whether to verify that input words are unique.\n                Defaults to True.\n            already_blocks (bool, optional): If True, assumes the input `W` is already a list of\n                `Block` objects instead of strings. Defaults to False.\n            verbose (bool, optional): If True, prints progress information during computation.\n\n        Example:\n            &gt;&gt;&gt; W = ['a*b', 'a*b*b', 'a*a*b','']\n            &gt;&gt;&gt; K = Filtration()\n            &gt;&gt;&gt; K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2)\n            &gt;&gt;&gt; K[1]\n            {a*b*(1,b): 0.3, a*(1,a)*b: 0.2}\n        \"\"\"\n        K = Filtration()\n        K.compute_d_skeleton(\n            W,\n            heights=None,\n            max_dim=max_dim,\n            alphabet=alphabet,\n            prod_symbol=prod_symbol,\n            check_duplicates=check_duplicates,\n            already_blocks=already_blocks,\n            verbose=verbose,\n        )\n        complex_dict = {dim: list(K[dim].keys()) for dim in K.filtration_dict}\n\n        self.complex_dict = complex_dict\n        self.height = height\n        self.dim = K.dim\n        self._alphabet = K.get_alphabet()\n\n        del K\n\n    def get_maximal_blocks(self):\n        \"\"\"\n        Return the maximal blocks of the complex, ordered by subfaces.\n\n        A block is maximal if it is not a subface of any higher-dimensional block.\n        The method identifies all such maximal blocks in each dimension and returns\n        them as a dictionary.\n\n        Returns:\n            dict[int, list[Block]]: A dictionary mapping each dimension to a list\n            of maximal blocks (i.e., blocks not covered by higher-dimensional ones).\n\n        Notes:\n            - Empty dimensions are removed from the output dictionary.\n        \"\"\"\n        covered_dict = {}\n        max_dim = self.dim\n\n        if max_dim &gt;= 0:\n            for dim in range(max_dim, -1, -1):\n                covered_dict[dim - 1] = set([])\n                for block in self.complex_dict[dim]:\n                    covered_dict[dim - 1].update(block.get_all_facets())\n\n            # Remove faces covered by a higher one\n            maximal_dict = {max_dim: self.complex_dict[max_dim].copy()}\n            for dim in range(max_dim):\n                maximal_dict[dim] = list(\n                    set(self.complex_dict[dim]).difference(covered_dict[dim])\n                )\n\n            # Remove empty dimensions\n            for dim in range(max_dim):\n                if len(maximal_dict[dim]) == 0:\n                    del maximal_dict[dim]\n            return maximal_dict\n        return {}\n\n    def get_complex(self, max_dim=None):\n        \"\"\"\n        Return a subcomplex of the current complex up to the specified dimension.\n\n        If `max_dim` is not provided or is greater than or equal to the current\n        dimension, the method returns the complex itself. Otherwise, it returns\n        a new `Complex` object containing only the blocks up to dimension `max_dim`.\n\n        Args:\n            max_dim (int or None, optional): Maximum dimension of blocks to include\n                in the returned complex. If None or greater than the complex\n                dimension, the full complex is returned.\n\n        Returns:\n            Complex: A subcomplex containing blocks up to dimension `max_dim`.\n        \"\"\"\n        if max_dim is None or max_dim &gt;= self.dim:\n            return self\n\n        complex_dict = {dim: list(self.complex_dict[dim]) for dim in range(max_dim + 1)}\n        for dim in range(max_dim, -1, -1):\n            if len(complex_dict[dim]) == 0:\n                del complex_dict[dim]\n            else:\n                break\n        return Complex(\n            alphabet=self._alphabet,\n            prod_symbol=self._prod_symbol,\n            complex_dict=complex_dict,\n            height=self.height,\n        )\n\n    def add_blocks(self, list_blocks, prod_symbol=None, already_blocks=False):\n        \"\"\"\n        Add new blocks to the Complex.\n\n        Extends the current Complex by inserting additional blocks and their faces.\n        Intended for expert use only, since the resulting structure may not be a full\n        Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks\n        are missing.\n\n        Args:\n            list_blocks (list[Block] or list[str]):\n                List of blocks to be added to the Filtration. If ``already_blocks`` is\n                False (default), the elements are assumed to be strings representing\n                blocks and will be converted. If True, they are assumed to be existing\n                ``Block`` objects.\n\n\n            prod_symbol (str or None, optional):\n                Product symbol used in block representation ('*', '.', or '').\n                If not specified, it is inferred from the input blocks.\n\n            already_blocks (bool, optional):\n                If True, elements of ``list_blocks`` are assumed to be valid ``Block``\n                objects. If False (default), the method attempts to convert the input\n                into blocks.\n\n        Notes:\n            The internal alphabet and product symbol are updated to ensure consistency.\n        \"\"\"\n        # Convert into blocks if needed\n        if already_blocks:\n            alphabet = _combine_blocks_alphabet(list_blocks, self._alphabet)\n        else:\n            list_blocks, alphabet, prod_symbol = _convert_words_to_blocks(\n                list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n            )\n        self._alphabet = alphabet\n\n        # Uniformalize prod_symbols pylint: disable=protected-access\n        new_prods = [blk._prod_symbol for blk in list_blocks] + [self._prod_symbol]\n        if \"*\" in new_prods:\n            prod_symbol = \"*\"\n        elif \".\" in new_prods:\n            prod_symbol = \".\"\n        else:\n            prod_symbol = \"\"\n        self._prod_symbol = prod_symbol\n        for blk in list_blocks:\n            blk._prod_symbol = self._prod_symbol\n\n        # Add blocks and faces to complex_dict\n        for block in list_blocks:\n            for face in block.get_all_faces(True):\n                dimension = face.dim\n                if dimension in self.complex_dict:\n                    if not face in self.complex_dict[dimension]:\n                        try:\n                            self.complex_dict[dimension].append(face)\n                        except KeyError:\n                            self.complex_dict[dimension] = [face]\n                else:\n                    self.complex_dict[dimension] = [face]\n\n        # Recompute dimension\n        self.dim = max(self.complex_dict, default=-1)\n\n    def remove_blocks(\n        self, list_blocks, prod_symbol=None, include_upfaces=True, already_blocks=False\n    ):\n        \"\"\"\n        Remove blocks from the Complex.\n\n        Deletes specified blocks and optionally their super-faces from the Complex.\n        Intended for expert use only, since the resulting structure may not be a full\n        Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks\n        are missing.\n\n        Args:\n            list_blocks (list of Block or string): A list of blocks to remove. If\n                `already_blocks` is False (default), the elements are assumed to be strings\n                representing blocks and will be converted. If True, they are assumed to be\n                existing Block objects.\n            prod_symbol (str or None, optional): Product symbol used in block\n                representation ( '*', '.', or ''). If not specified, it is inferred\n                from the input blocks.\n            include_upfaces (bool, optional): If True, all super faces of the specified blocks\n                are also removed, so the result is a subcomplex. Default is True.\n            already_blocks (bool, optional): If True, the elements of `list_blocks`\n                are assumed to be valid Block objects. If False (default), the method\n                attempts to convert the input into blocks.\n        \"\"\"\n        # Make sure it is a list\n        if not isinstance(list_blocks, list):\n            raise TypeError(\"list_blocks must be a list\")\n\n        # Convert into blocks if needed\n        if not already_blocks:\n            list_blocks, _alphabet, prod_symbol = _convert_words_to_blocks(\n                list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n            )\n\n        # Dictionary of blocks to remove\n        blocks_to_remove = {i: [] for i in range(self.dim + 1)}\n        for block in list_blocks:\n            if block.dim in self.complex_dict and block in self.complex_dict[block.dim]:\n                blocks_to_remove[block.dim].append(block)\n\n        # Find super-faces if needed\n        if include_upfaces:\n            for dimension in range(1, self.dim + 1):\n                for block in self.complex_dict[dimension]:\n                    facets = block.get_all_facets()\n                    if any(\n                        facet in blocks_to_remove[dimension - 1] for facet in facets\n                    ):\n                        blocks_to_remove[dimension].append(block)\n\n        # Remove blocks\n        for dimension in blocks_to_remove:\n            for block in blocks_to_remove[dimension]:\n                if block in self.complex_dict[dimension]:\n                    self.complex_dict[dimension].remove(block)\n\n        # Update complex_dict\n        for dimension in range(self.dim, -1, -1):\n            if len(self.complex_dict[dimension]) == 0:\n                del self.complex_dict[dimension]\n            else:\n                break\n\n        # Recompute dimension\n        self.dim = max(self.complex_dict, default=-1)\n\n    def euler_characteristic(self):\n        \"\"\"\n        This method computes the Euler characteristic of the complex.\n        \"\"\"\n        faces = [(k, len(self.complex_dict[k])) for k in self.complex_dict]\n        characteristic = int(np.sum([(-1) ** k * m for (k, m) in faces]))\n        return characteristic\n\n    def __getitem__(self, key):\n        if 0 &lt;= key &lt;= self.dim:\n            return self.complex_dict[key]\n        return {}\n\n    def get_graph(\n        self,\n        show_labels=True,\n        max_dim=5,\n        positions=None,\n        initial_positions=None,\n        fixed=None,\n        recompute=False,\n        colors_by_dim=None,\n        ax=None,\n    ):\n        \"\"\"\n        Generate a graphical representation of the complex up to a specified dimension.\n\n        Positions of vertices can be computed automatically or provided manually.\n        Only accurate for low-dimensional complexes (typically dim &lt;= 3).\n\n        Args:\n            show_labels (bool, optional): Whether to display labels on the vertices. Defaults to True.\n            max_dim (int, optional): Maximum dimension of blocks to include in the graph. Defaults to 5.\n            positions (dict, optional): Dictionary of vertex positions.\n                If None, positions are computed automatically. Once computed, they are reused\n                everytime this method is called, unless recompute is set to True.\n            initial_positions (dict, optional): Initial positions used to seed the\n                automatic layout algorithm.\n            fixed (list or None, optional): List of vertex keys to fix in place when computing positions.\n                Defaults to None.\n            recompute (bool, optional): Whether to recompute vertex positions even\n                if already stored. Defaults to False.\n            colors_by_dim (list of str, optional): List of colors to use for each dimension.\n                If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].\n            ax (matplotlib.axes._subplots.Axes3DSubplot, optional): A Matplotlib Axes\n                object to draw the plot on. If None, a new figure and axes are created.\n                Defaults to None.\n\n        Returns:\n            matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.\n        \"\"\"\n        if self.dim == -1:\n            return None\n        if (positions is None) or recompute:\n            if (self._positions_dict is None) or recompute:\n                self._positions_dict = graphics.compute_vertex_positions(\n                    self, pos0=initial_positions, fixed=fixed\n                )\n            # Make sure position includes all vertices\n            elif any(vertex not in self._positions_dict for vertex in self[0]):\n                # Update with pos0\n                if isinstance(initial_positions, dict):\n                    for vertex in initial_positions:\n                        self._positions_dict[vertex] = initial_positions[vertex]\n                # Compute for all vertices\n                self._positions_dict = graphics.compute_vertex_positions(\n                    self,\n                    pos0=self._positions_dict,\n                    fixed=list(self._positions_dict.keys()),\n                )\n\n            # Get the positions\n            positions = self._positions_dict\n\n            ax = graphics.make_graph(\n                self,\n                pos=positions,\n                show_labels=show_labels,\n                max_dim=max_dim,\n                height=None,\n                already_complex=True,\n                colors_by_dim=colors_by_dim,\n                ax=ax,\n            )\n\n        return ax\n\n    def get_betti_numbers_z2(self, max_dim=None):\n        \"\"\"\n        Returns the betti numbers in Z_2 coefficients up to the specified dimension max_dim.\n        \"\"\"\n        # Import csc_matrix\n        from scipy.sparse import csc_matrix\n\n        if max_dim is None or max_dim &gt;= self.dim:\n            max_dim = self.dim\n            using_skeleton = False\n        elif max_dim == self.dim - 1:\n            max_dim = self.dim\n            using_skeleton = True\n        else:\n            max_dim += 1\n            using_skeleton = True\n\n        # Order the blocks according to their dimension\n        ordered_blocks = []\n        for d in range(max_dim + 1):\n            ordered_blocks += self[d]\n        ordered_blocks.sort(key=lambda B: B.dim)\n\n        ordered_blocks_dict = {ordered_blocks[i]: i for i in range(len(ordered_blocks))}\n\n        # Construct the boundary matrix\n        cols = []\n        rows = []\n        data = []\n        for id_col, block in enumerate(ordered_blocks):\n            facets = block.get_all_facets()\n            for face in facets:\n                cols.append(id_col)\n                rows.append(ordered_blocks_dict[face])\n                data.append(1)\n\n        N = len(ordered_blocks)\n        boundary_matrix = csc_matrix((data, (rows, cols)), shape=(N, N)).tolil()\n\n        # Perform row reduction (we follow the algorithm from https://arxiv.org/pdf/1506.08903)\n        low = []  # maps row index to pivot column index\n        betti_numbers = {dim: 0 for dim in range(max_dim + 1)}\n\n        for j in range(N):\n            col = boundary_matrix.getcol(j)\n            if col.nnz &gt; 0:\n                # Set initial value for low(j)\n                low_j = col.nonzero()[0][-1]\n                while low_j in low:\n                    i = low.index(low_j)\n                    # add column i to column j\n                    col = col + boundary_matrix.getcol(i)\n                    col.data = col.data % 2  # Make adition modulo 2\n                    col.eliminate_zeros()\n                    if col.nnz &gt; 0:\n                        low_j = col.nonzero()[0][-1]  # update low_j value\n                    else:\n                        low_j = -1\n                        break\n                boundary_matrix[:, j] = col  # update column j in the matrix\n                low.append(low_j)  # Save value for low_j\n            else:\n                # Set -1, for undefined low(j)\n                low.append(-1)\n\n        # Extract surviving cycles\n        for j, low_j in enumerate(low):\n            if low_j &lt; 0 and not j in low:\n                dim = ordered_blocks[j].dim\n                betti_numbers[dim] += 1\n\n        if using_skeleton:\n            if max_dim in betti_numbers:\n                del betti_numbers[max_dim]\n\n        return betti_numbers\n\n    def get_chain_complex_sage(self, get_ordered_blocks=False):\n        \"\"\"\n        Construct and return the associated chain complex as a SageMath object.\n\n        This method is intended to be used in a SageMath kernel. It builds a chain complex\n        using Sage's `ChainComplex()` constructor. Optionally, it can also return the blocks\n        sorted within each dimension.\n\n        Args:\n            get_ordered_blocks (bool, optional): If True, also return the blocks\n                ordered by their expressions within each dimension. Defaults to False.\n\n        Returns:\n            ChainComplex or tuple[ChainComplex, dict[int, list[Block]]]:\n                - If `get_ordered_blocks` is False, returns a ChainComplex object\n                  representing the boundary operators.\n                - If `get_ordered_blocks` is True, returns a tuple `(ChainComplex, Blocks_ordered)`,\n                  where `Blocks_ordered` is a dictionary of lists of blocks sorted by expression.\n         Notes:\n            - Requires SageMath to be installed and accessible in the current environment.\n            - If SageMath is not found, the function prints a warning and returns None.\n            - Any other errors during construction are caught and printed.\n        \"\"\"\n        try:\n            from InDelsTopo import homology_sagemath\n\n            return homology_sagemath.create_chain_complex(\n                self.complex_dict, get_ordered_blocks\n            )\n        except ImportError:\n            print(\n                \"Could not find SageMath functions. \"\n                \"This module requires SageMath to run and cannot be \"\n                \"executed in a standard Python environment.\"\n            )\n            return None\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return None\n\n    def get_homology_sage(\n        self, save_chain_complex=False, used_saved_chain_complex=True, **kwargs\n    ):\n        \"\"\"\n        Return the homology of the associated chain complex using SageMath.\n\n        This method should be run in a SageMath kernel. It constructs a SageMath chain complex\n        and computes its homology using Sage's built-in `homology()` method.\n\n        Parameters:\n            save_chain_complex (bool): If True, the chain complex is saved as an attribute\n                                       (`self._sage_chain_complex`) to speed up future computations.\n            used_saved_chain_complex (bool): If True, it will attempt to use the saved chain_complex\n                                            attribute, otherwise, it will be computed from scratch.\n            **kwargs: Additional keyword arguments passed directly to SageMath's `homology()` method.\n\n        Returns:\n            The homology object returned by SageMath.\n        \"\"\"\n        chain_complex = getattr(self, \"_sage_chain_complex\", None)\n        if not used_saved_chain_complex or chain_complex is None:\n            chain_complex = self.get_chain_complex_sage()\n\n        if save_chain_complex:\n            self._sage_chain_complex = chain_complex\n\n        return chain_complex.homology(**kwargs)\n\n    def __str__(self):\n        to_print = \"Insertion Chain Complex \\n\"\n        to_print += \"alphabet: \" + str(self._alphabet) + \".\\n\"\n        if not self.height is None:\n            to_print += \"height: \" + str(self.height) + \".\\n\"\n        to_print += \"dimension: \" + str(self.dim) + \".\\n\"\n        to_print += \"vertices: \" + str(len(self[0])) + \".\\n\"\n        to_print += (\n            \"blocks: \" + str(sum([len(self[k]) for k in range(self.dim + 1)])) + \".\"\n        )\n        return to_print\n\n    def __repr__(self):\n        return self.__str__()\n\n    def get_alphabet(self):\n        \"\"\"Returns the alphabet attribute.\"\"\"\n        return self._alphabet\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.__init__","title":"<code>__init__(alphabet=None, prod_symbol=None, *, complex_dict=None, height=None)</code>","text":"<p>Initialize an Insertion Chain Complex.</p> <p>This constructor creates a new complex object, which can either start empty (with no blocks) or be initialized from a given dictionary of blocks. Optionally, the complex can store a height value, useful when representing a level in a filtration.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>Alphabet | None</code> <p>The alphabet containing all symbols to be used. Defaults to None.</p> <code>None</code> <code>prod_symbol</code> <code>str | None</code> <p>Product symbol used for block construction, Must be one of {'', '', '.'}. If None, it is inferred from the expression: set to '' if '*' appears, to '.' if '.' appears, or to '' (concatenation) otherwise.</p> <code>None</code> <code>complex_dict</code> <code>dict[int, list[Block]] | None</code> <p>Mapping from dimension <code>d</code> to the list of d-dimensional blocks. If provided, it initializes the complex structure directly. Defaults to None.</p> <code>None</code> <code>height</code> <code>float | None</code> <p>Height value associated with the complex, used when part of a filtration. Defaults to None.</p> <code>None</code> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def __init__(\n    self, alphabet=None, prod_symbol=None, *, complex_dict=None, height=None\n):\n    \"\"\"\n    Initialize an Insertion Chain Complex.\n\n    This constructor creates a new complex object, which can either start empty\n    (with no blocks) or be initialized from a given dictionary of blocks.\n    Optionally, the complex can store a height value, useful when representing\n    a level in a filtration.\n\n    Args:\n        alphabet (Alphabet | None, optional): The alphabet containing all symbols\n            to be used. Defaults to None.\n        prod_symbol (str | None, optional): Product symbol used for block construction,\n            Must be one of {'', '*', '.'}. If None, it is inferred from the expression:\n            set to '*' if '*' appears, to '.' if '.' appears, or to '' (concatenation)\n            otherwise.\n        complex_dict (dict[int, list[Block]] | None, optional): Mapping from\n            dimension `d` to the list of d-dimensional blocks. If provided, it\n            initializes the complex structure directly. Defaults to None.\n        height (float | None, optional): Height value associated with the complex,\n            used when part of a filtration. Defaults to None.\n    \"\"\"\n    self._alphabet = alphabet\n    self._prod_symbol = prod_symbol\n    self.dim = -1\n    self.complex_dict = {}\n    self.height = None\n    self._positions_dict = None\n\n    if not complex_dict is None:\n        self.dim = max(complex_dict.keys(), default=-1)\n        self.complex_dict = complex_dict\n        self.height = height\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.add_blocks","title":"<code>add_blocks(list_blocks, prod_symbol=None, already_blocks=False)</code>","text":"<p>Add new blocks to the Complex.</p> <p>Extends the current Complex by inserting additional blocks and their faces. Intended for expert use only, since the resulting structure may not be a full Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks are missing.</p> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list[Block] or list[str]</code> <p>List of blocks to be added to the Filtration. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing <code>Block</code> objects.</p> required <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation ('*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>already_blocks</code> <code>bool</code> <p>If True, elements of <code>list_blocks</code> are assumed to be valid <code>Block</code> objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code> Notes <p>The internal alphabet and product symbol are updated to ensure consistency.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def add_blocks(self, list_blocks, prod_symbol=None, already_blocks=False):\n    \"\"\"\n    Add new blocks to the Complex.\n\n    Extends the current Complex by inserting additional blocks and their faces.\n    Intended for expert use only, since the resulting structure may not be a full\n    Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks\n    are missing.\n\n    Args:\n        list_blocks (list[Block] or list[str]):\n            List of blocks to be added to the Filtration. If ``already_blocks`` is\n            False (default), the elements are assumed to be strings representing\n            blocks and will be converted. If True, they are assumed to be existing\n            ``Block`` objects.\n\n\n        prod_symbol (str or None, optional):\n            Product symbol used in block representation ('*', '.', or '').\n            If not specified, it is inferred from the input blocks.\n\n        already_blocks (bool, optional):\n            If True, elements of ``list_blocks`` are assumed to be valid ``Block``\n            objects. If False (default), the method attempts to convert the input\n            into blocks.\n\n    Notes:\n        The internal alphabet and product symbol are updated to ensure consistency.\n    \"\"\"\n    # Convert into blocks if needed\n    if already_blocks:\n        alphabet = _combine_blocks_alphabet(list_blocks, self._alphabet)\n    else:\n        list_blocks, alphabet, prod_symbol = _convert_words_to_blocks(\n            list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n        )\n    self._alphabet = alphabet\n\n    # Uniformalize prod_symbols pylint: disable=protected-access\n    new_prods = [blk._prod_symbol for blk in list_blocks] + [self._prod_symbol]\n    if \"*\" in new_prods:\n        prod_symbol = \"*\"\n    elif \".\" in new_prods:\n        prod_symbol = \".\"\n    else:\n        prod_symbol = \"\"\n    self._prod_symbol = prod_symbol\n    for blk in list_blocks:\n        blk._prod_symbol = self._prod_symbol\n\n    # Add blocks and faces to complex_dict\n    for block in list_blocks:\n        for face in block.get_all_faces(True):\n            dimension = face.dim\n            if dimension in self.complex_dict:\n                if not face in self.complex_dict[dimension]:\n                    try:\n                        self.complex_dict[dimension].append(face)\n                    except KeyError:\n                        self.complex_dict[dimension] = [face]\n            else:\n                self.complex_dict[dimension] = [face]\n\n    # Recompute dimension\n    self.dim = max(self.complex_dict, default=-1)\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.compute_d_skeleton","title":"<code>compute_d_skeleton(W, height=None, max_dim=10, alphabet=None, prod_symbol=None, check_duplicates=True, already_blocks=False, verbose=False)</code>","text":"<p>Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W]. This method replaces any existing data in the Complex with a new complex supported on <code>W</code>.</p> <p>This method constructs all valid blocks up to the specified maximum dimension (<code>max_dim</code>) for a given set of words <code>W</code>. It begins by computing the 0- and 1-skeletons (vertices and edges), then iteratively extends to higher dimensions.</p> <p>It updates the internal <code>complex_dict</code> to the blocks supported on <code>W</code>.</p> <p>Parameters:</p> Name Type Description Default <code>W</code> <code>list of str or Block</code> <p>List of words (or blocks, if <code>already_blocks=True</code>) forming the base of the complex.</p> required <code>height</code> <code>float</code> <p>Height value associated with the complex, used when part of a filtration. Defaults to None.</p> <code>None</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of the skeleton to compute. Defaults to 10.</p> <code>10</code> <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object used together with the internal <code>self._alphabet</code> and any letters inferred from <code>W</code>. If provided, its symbols are merged with <code>self._alphabet</code>; otherwise, the new symbols are inferred entirely from the given words.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>Product symbol for block construction ('*', '.', or ''). If None, inferred automatically.</p> <code>None</code> <code>check_duplicates</code> <code>bool</code> <p>Whether to verify that input words are unique. Defaults to True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, assumes the input <code>W</code> is already a list of <code>Block</code> objects instead of strings. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints progress information during computation.</p> <code>False</code> Example <p>W = ['ab', 'abb', 'aab',''] K = Filtration() K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2) K[1] {ab(1,b): 0.3, a(1,a)*b: 0.2}</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def compute_d_skeleton(\n    self,\n    W,\n    height=None,\n    max_dim=10,\n    alphabet=None,\n    prod_symbol=None,\n    check_duplicates=True,\n    already_blocks=False,\n    verbose=False,\n):\n    \"\"\"\n    Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W].\n    This method replaces any existing data in the Complex with a new complex supported on `W`.\n\n    This method constructs all valid blocks up to the specified maximum dimension (`max_dim`)\n    for a given set of words `W`. It begins by computing the 0- and 1-skeletons (vertices and edges),\n    then iteratively extends to higher dimensions.\n\n    It updates the internal `complex_dict` to the blocks supported on `W`.\n\n    Args:\n        W (list of str or Block): List of words (or blocks, if `already_blocks=True`)\n            forming the base of the complex.\n        height (float, optional): Height value associated with the complex,\n            used when part of a filtration. Defaults to None.\n        max_dim (int, optional): Maximum dimension of the skeleton to compute. Defaults to 10.\n        alphabet (Alphabet, optional): Alphabet object used together with the internal\n            `self._alphabet` and any letters inferred from `W`. If provided, its symbols\n            are merged with `self._alphabet`; otherwise, the new symbols are inferred entirely\n            from the given words.\n        prod_symbol (str, optional): Product symbol for block construction ('*', '.', or '').\n            If None, inferred automatically.\n        check_duplicates (bool, optional): Whether to verify that input words are unique.\n            Defaults to True.\n        already_blocks (bool, optional): If True, assumes the input `W` is already a list of\n            `Block` objects instead of strings. Defaults to False.\n        verbose (bool, optional): If True, prints progress information during computation.\n\n    Example:\n        &gt;&gt;&gt; W = ['a*b', 'a*b*b', 'a*a*b','']\n        &gt;&gt;&gt; K = Filtration()\n        &gt;&gt;&gt; K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2)\n        &gt;&gt;&gt; K[1]\n        {a*b*(1,b): 0.3, a*(1,a)*b: 0.2}\n    \"\"\"\n    K = Filtration()\n    K.compute_d_skeleton(\n        W,\n        heights=None,\n        max_dim=max_dim,\n        alphabet=alphabet,\n        prod_symbol=prod_symbol,\n        check_duplicates=check_duplicates,\n        already_blocks=already_blocks,\n        verbose=verbose,\n    )\n    complex_dict = {dim: list(K[dim].keys()) for dim in K.filtration_dict}\n\n    self.complex_dict = complex_dict\n    self.height = height\n    self.dim = K.dim\n    self._alphabet = K.get_alphabet()\n\n    del K\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.euler_characteristic","title":"<code>euler_characteristic()</code>","text":"<p>This method computes the Euler characteristic of the complex.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def euler_characteristic(self):\n    \"\"\"\n    This method computes the Euler characteristic of the complex.\n    \"\"\"\n    faces = [(k, len(self.complex_dict[k])) for k in self.complex_dict]\n    characteristic = int(np.sum([(-1) ** k * m for (k, m) in faces]))\n    return characteristic\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.get_alphabet","title":"<code>get_alphabet()</code>","text":"<p>Returns the alphabet attribute.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def get_alphabet(self):\n    \"\"\"Returns the alphabet attribute.\"\"\"\n    return self._alphabet\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.get_betti_numbers_z2","title":"<code>get_betti_numbers_z2(max_dim=None)</code>","text":"<p>Returns the betti numbers in Z_2 coefficients up to the specified dimension max_dim.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def get_betti_numbers_z2(self, max_dim=None):\n    \"\"\"\n    Returns the betti numbers in Z_2 coefficients up to the specified dimension max_dim.\n    \"\"\"\n    # Import csc_matrix\n    from scipy.sparse import csc_matrix\n\n    if max_dim is None or max_dim &gt;= self.dim:\n        max_dim = self.dim\n        using_skeleton = False\n    elif max_dim == self.dim - 1:\n        max_dim = self.dim\n        using_skeleton = True\n    else:\n        max_dim += 1\n        using_skeleton = True\n\n    # Order the blocks according to their dimension\n    ordered_blocks = []\n    for d in range(max_dim + 1):\n        ordered_blocks += self[d]\n    ordered_blocks.sort(key=lambda B: B.dim)\n\n    ordered_blocks_dict = {ordered_blocks[i]: i for i in range(len(ordered_blocks))}\n\n    # Construct the boundary matrix\n    cols = []\n    rows = []\n    data = []\n    for id_col, block in enumerate(ordered_blocks):\n        facets = block.get_all_facets()\n        for face in facets:\n            cols.append(id_col)\n            rows.append(ordered_blocks_dict[face])\n            data.append(1)\n\n    N = len(ordered_blocks)\n    boundary_matrix = csc_matrix((data, (rows, cols)), shape=(N, N)).tolil()\n\n    # Perform row reduction (we follow the algorithm from https://arxiv.org/pdf/1506.08903)\n    low = []  # maps row index to pivot column index\n    betti_numbers = {dim: 0 for dim in range(max_dim + 1)}\n\n    for j in range(N):\n        col = boundary_matrix.getcol(j)\n        if col.nnz &gt; 0:\n            # Set initial value for low(j)\n            low_j = col.nonzero()[0][-1]\n            while low_j in low:\n                i = low.index(low_j)\n                # add column i to column j\n                col = col + boundary_matrix.getcol(i)\n                col.data = col.data % 2  # Make adition modulo 2\n                col.eliminate_zeros()\n                if col.nnz &gt; 0:\n                    low_j = col.nonzero()[0][-1]  # update low_j value\n                else:\n                    low_j = -1\n                    break\n            boundary_matrix[:, j] = col  # update column j in the matrix\n            low.append(low_j)  # Save value for low_j\n        else:\n            # Set -1, for undefined low(j)\n            low.append(-1)\n\n    # Extract surviving cycles\n    for j, low_j in enumerate(low):\n        if low_j &lt; 0 and not j in low:\n            dim = ordered_blocks[j].dim\n            betti_numbers[dim] += 1\n\n    if using_skeleton:\n        if max_dim in betti_numbers:\n            del betti_numbers[max_dim]\n\n    return betti_numbers\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.get_chain_complex_sage","title":"<code>get_chain_complex_sage(get_ordered_blocks=False)</code>","text":"<p>Construct and return the associated chain complex as a SageMath object.</p> <p>This method is intended to be used in a SageMath kernel. It builds a chain complex using Sage's <code>ChainComplex()</code> constructor. Optionally, it can also return the blocks sorted within each dimension.</p> <p>Parameters:</p> Name Type Description Default <code>get_ordered_blocks</code> <code>bool</code> <p>If True, also return the blocks ordered by their expressions within each dimension. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>ChainComplex or tuple[ChainComplex, dict[int, list[Block]]]: - If <code>get_ordered_blocks</code> is False, returns a ChainComplex object   representing the boundary operators. - If <code>get_ordered_blocks</code> is True, returns a tuple <code>(ChainComplex, Blocks_ordered)</code>,   where <code>Blocks_ordered</code> is a dictionary of lists of blocks sorted by expression.</p> <p>Notes:     - Requires SageMath to be installed and accessible in the current environment.     - If SageMath is not found, the function prints a warning and returns None.     - Any other errors during construction are caught and printed.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def get_chain_complex_sage(self, get_ordered_blocks=False):\n    \"\"\"\n    Construct and return the associated chain complex as a SageMath object.\n\n    This method is intended to be used in a SageMath kernel. It builds a chain complex\n    using Sage's `ChainComplex()` constructor. Optionally, it can also return the blocks\n    sorted within each dimension.\n\n    Args:\n        get_ordered_blocks (bool, optional): If True, also return the blocks\n            ordered by their expressions within each dimension. Defaults to False.\n\n    Returns:\n        ChainComplex or tuple[ChainComplex, dict[int, list[Block]]]:\n            - If `get_ordered_blocks` is False, returns a ChainComplex object\n              representing the boundary operators.\n            - If `get_ordered_blocks` is True, returns a tuple `(ChainComplex, Blocks_ordered)`,\n              where `Blocks_ordered` is a dictionary of lists of blocks sorted by expression.\n     Notes:\n        - Requires SageMath to be installed and accessible in the current environment.\n        - If SageMath is not found, the function prints a warning and returns None.\n        - Any other errors during construction are caught and printed.\n    \"\"\"\n    try:\n        from InDelsTopo import homology_sagemath\n\n        return homology_sagemath.create_chain_complex(\n            self.complex_dict, get_ordered_blocks\n        )\n    except ImportError:\n        print(\n            \"Could not find SageMath functions. \"\n            \"This module requires SageMath to run and cannot be \"\n            \"executed in a standard Python environment.\"\n        )\n        return None\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.get_complex","title":"<code>get_complex(max_dim=None)</code>","text":"<p>Return a subcomplex of the current complex up to the specified dimension.</p> <p>If <code>max_dim</code> is not provided or is greater than or equal to the current dimension, the method returns the complex itself. Otherwise, it returns a new <code>Complex</code> object containing only the blocks up to dimension <code>max_dim</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_dim</code> <code>int or None</code> <p>Maximum dimension of blocks to include in the returned complex. If None or greater than the complex dimension, the full complex is returned.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Complex</code> <p>A subcomplex containing blocks up to dimension <code>max_dim</code>.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def get_complex(self, max_dim=None):\n    \"\"\"\n    Return a subcomplex of the current complex up to the specified dimension.\n\n    If `max_dim` is not provided or is greater than or equal to the current\n    dimension, the method returns the complex itself. Otherwise, it returns\n    a new `Complex` object containing only the blocks up to dimension `max_dim`.\n\n    Args:\n        max_dim (int or None, optional): Maximum dimension of blocks to include\n            in the returned complex. If None or greater than the complex\n            dimension, the full complex is returned.\n\n    Returns:\n        Complex: A subcomplex containing blocks up to dimension `max_dim`.\n    \"\"\"\n    if max_dim is None or max_dim &gt;= self.dim:\n        return self\n\n    complex_dict = {dim: list(self.complex_dict[dim]) for dim in range(max_dim + 1)}\n    for dim in range(max_dim, -1, -1):\n        if len(complex_dict[dim]) == 0:\n            del complex_dict[dim]\n        else:\n            break\n    return Complex(\n        alphabet=self._alphabet,\n        prod_symbol=self._prod_symbol,\n        complex_dict=complex_dict,\n        height=self.height,\n    )\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.get_graph","title":"<code>get_graph(show_labels=True, max_dim=5, positions=None, initial_positions=None, fixed=None, recompute=False, colors_by_dim=None, ax=None)</code>","text":"<p>Generate a graphical representation of the complex up to a specified dimension.</p> <p>Positions of vertices can be computed automatically or provided manually. Only accurate for low-dimensional complexes (typically dim &lt;= 3).</p> <p>Parameters:</p> Name Type Description Default <code>show_labels</code> <code>bool</code> <p>Whether to display labels on the vertices. Defaults to True.</p> <code>True</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of blocks to include in the graph. Defaults to 5.</p> <code>5</code> <code>positions</code> <code>dict</code> <p>Dictionary of vertex positions. If None, positions are computed automatically. Once computed, they are reused everytime this method is called, unless recompute is set to True.</p> <code>None</code> <code>initial_positions</code> <code>dict</code> <p>Initial positions used to seed the automatic layout algorithm.</p> <code>None</code> <code>fixed</code> <code>list or None</code> <p>List of vertex keys to fix in place when computing positions. Defaults to None.</p> <code>None</code> <code>recompute</code> <code>bool</code> <p>Whether to recompute vertex positions even if already stored. Defaults to False.</p> <code>False</code> <code>colors_by_dim</code> <code>list of str</code> <p>List of colors to use for each dimension. If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].</p> <code>None</code> <code>ax</code> <code>Axes3DSubplot</code> <p>A Matplotlib Axes object to draw the plot on. If None, a new figure and axes are created. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def get_graph(\n    self,\n    show_labels=True,\n    max_dim=5,\n    positions=None,\n    initial_positions=None,\n    fixed=None,\n    recompute=False,\n    colors_by_dim=None,\n    ax=None,\n):\n    \"\"\"\n    Generate a graphical representation of the complex up to a specified dimension.\n\n    Positions of vertices can be computed automatically or provided manually.\n    Only accurate for low-dimensional complexes (typically dim &lt;= 3).\n\n    Args:\n        show_labels (bool, optional): Whether to display labels on the vertices. Defaults to True.\n        max_dim (int, optional): Maximum dimension of blocks to include in the graph. Defaults to 5.\n        positions (dict, optional): Dictionary of vertex positions.\n            If None, positions are computed automatically. Once computed, they are reused\n            everytime this method is called, unless recompute is set to True.\n        initial_positions (dict, optional): Initial positions used to seed the\n            automatic layout algorithm.\n        fixed (list or None, optional): List of vertex keys to fix in place when computing positions.\n            Defaults to None.\n        recompute (bool, optional): Whether to recompute vertex positions even\n            if already stored. Defaults to False.\n        colors_by_dim (list of str, optional): List of colors to use for each dimension.\n            If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].\n        ax (matplotlib.axes._subplots.Axes3DSubplot, optional): A Matplotlib Axes\n            object to draw the plot on. If None, a new figure and axes are created.\n            Defaults to None.\n\n    Returns:\n        matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.\n    \"\"\"\n    if self.dim == -1:\n        return None\n    if (positions is None) or recompute:\n        if (self._positions_dict is None) or recompute:\n            self._positions_dict = graphics.compute_vertex_positions(\n                self, pos0=initial_positions, fixed=fixed\n            )\n        # Make sure position includes all vertices\n        elif any(vertex not in self._positions_dict for vertex in self[0]):\n            # Update with pos0\n            if isinstance(initial_positions, dict):\n                for vertex in initial_positions:\n                    self._positions_dict[vertex] = initial_positions[vertex]\n            # Compute for all vertices\n            self._positions_dict = graphics.compute_vertex_positions(\n                self,\n                pos0=self._positions_dict,\n                fixed=list(self._positions_dict.keys()),\n            )\n\n        # Get the positions\n        positions = self._positions_dict\n\n        ax = graphics.make_graph(\n            self,\n            pos=positions,\n            show_labels=show_labels,\n            max_dim=max_dim,\n            height=None,\n            already_complex=True,\n            colors_by_dim=colors_by_dim,\n            ax=ax,\n        )\n\n    return ax\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.get_homology_sage","title":"<code>get_homology_sage(save_chain_complex=False, used_saved_chain_complex=True, **kwargs)</code>","text":"<p>Return the homology of the associated chain complex using SageMath.</p> <p>This method should be run in a SageMath kernel. It constructs a SageMath chain complex and computes its homology using Sage's built-in <code>homology()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>save_chain_complex</code> <code>bool</code> <p>If True, the chain complex is saved as an attribute                        (<code>self._sage_chain_complex</code>) to speed up future computations.</p> <code>False</code> <code>used_saved_chain_complex</code> <code>bool</code> <p>If True, it will attempt to use the saved chain_complex                             attribute, otherwise, it will be computed from scratch.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments passed directly to SageMath's <code>homology()</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The homology object returned by SageMath.</p> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def get_homology_sage(\n    self, save_chain_complex=False, used_saved_chain_complex=True, **kwargs\n):\n    \"\"\"\n    Return the homology of the associated chain complex using SageMath.\n\n    This method should be run in a SageMath kernel. It constructs a SageMath chain complex\n    and computes its homology using Sage's built-in `homology()` method.\n\n    Parameters:\n        save_chain_complex (bool): If True, the chain complex is saved as an attribute\n                                   (`self._sage_chain_complex`) to speed up future computations.\n        used_saved_chain_complex (bool): If True, it will attempt to use the saved chain_complex\n                                        attribute, otherwise, it will be computed from scratch.\n        **kwargs: Additional keyword arguments passed directly to SageMath's `homology()` method.\n\n    Returns:\n        The homology object returned by SageMath.\n    \"\"\"\n    chain_complex = getattr(self, \"_sage_chain_complex\", None)\n    if not used_saved_chain_complex or chain_complex is None:\n        chain_complex = self.get_chain_complex_sage()\n\n    if save_chain_complex:\n        self._sage_chain_complex = chain_complex\n\n    return chain_complex.homology(**kwargs)\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.get_maximal_blocks","title":"<code>get_maximal_blocks()</code>","text":"<p>Return the maximal blocks of the complex, ordered by subfaces.</p> <p>A block is maximal if it is not a subface of any higher-dimensional block. The method identifies all such maximal blocks in each dimension and returns them as a dictionary.</p> <p>Returns:</p> Type Description <p>dict[int, list[Block]]: A dictionary mapping each dimension to a list</p> <p>of maximal blocks (i.e., blocks not covered by higher-dimensional ones).</p> Notes <ul> <li>Empty dimensions are removed from the output dictionary.</li> </ul> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def get_maximal_blocks(self):\n    \"\"\"\n    Return the maximal blocks of the complex, ordered by subfaces.\n\n    A block is maximal if it is not a subface of any higher-dimensional block.\n    The method identifies all such maximal blocks in each dimension and returns\n    them as a dictionary.\n\n    Returns:\n        dict[int, list[Block]]: A dictionary mapping each dimension to a list\n        of maximal blocks (i.e., blocks not covered by higher-dimensional ones).\n\n    Notes:\n        - Empty dimensions are removed from the output dictionary.\n    \"\"\"\n    covered_dict = {}\n    max_dim = self.dim\n\n    if max_dim &gt;= 0:\n        for dim in range(max_dim, -1, -1):\n            covered_dict[dim - 1] = set([])\n            for block in self.complex_dict[dim]:\n                covered_dict[dim - 1].update(block.get_all_facets())\n\n        # Remove faces covered by a higher one\n        maximal_dict = {max_dim: self.complex_dict[max_dim].copy()}\n        for dim in range(max_dim):\n            maximal_dict[dim] = list(\n                set(self.complex_dict[dim]).difference(covered_dict[dim])\n            )\n\n        # Remove empty dimensions\n        for dim in range(max_dim):\n            if len(maximal_dict[dim]) == 0:\n                del maximal_dict[dim]\n        return maximal_dict\n    return {}\n</code></pre>"},{"location":"reference/#InDelsTopo.Complex.remove_blocks","title":"<code>remove_blocks(list_blocks, prod_symbol=None, include_upfaces=True, already_blocks=False)</code>","text":"<p>Remove blocks from the Complex.</p> <p>Deletes specified blocks and optionally their super-faces from the Complex. Intended for expert use only, since the resulting structure may not be a full Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks are missing.</p> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list of Block or string</code> <p>A list of blocks to remove. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing Block objects.</p> required <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation ( '*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>include_upfaces</code> <code>bool</code> <p>If True, all super faces of the specified blocks are also removed, so the result is a subcomplex. Default is True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, the elements of <code>list_blocks</code> are assumed to be valid Block objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code> Source code in <code>InDelsTopo/complex.py</code> <pre><code>def remove_blocks(\n    self, list_blocks, prod_symbol=None, include_upfaces=True, already_blocks=False\n):\n    \"\"\"\n    Remove blocks from the Complex.\n\n    Deletes specified blocks and optionally their super-faces from the Complex.\n    Intended for expert use only, since the resulting structure may not be a full\n    Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks\n    are missing.\n\n    Args:\n        list_blocks (list of Block or string): A list of blocks to remove. If\n            `already_blocks` is False (default), the elements are assumed to be strings\n            representing blocks and will be converted. If True, they are assumed to be\n            existing Block objects.\n        prod_symbol (str or None, optional): Product symbol used in block\n            representation ( '*', '.', or ''). If not specified, it is inferred\n            from the input blocks.\n        include_upfaces (bool, optional): If True, all super faces of the specified blocks\n            are also removed, so the result is a subcomplex. Default is True.\n        already_blocks (bool, optional): If True, the elements of `list_blocks`\n            are assumed to be valid Block objects. If False (default), the method\n            attempts to convert the input into blocks.\n    \"\"\"\n    # Make sure it is a list\n    if not isinstance(list_blocks, list):\n        raise TypeError(\"list_blocks must be a list\")\n\n    # Convert into blocks if needed\n    if not already_blocks:\n        list_blocks, _alphabet, prod_symbol = _convert_words_to_blocks(\n            list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n        )\n\n    # Dictionary of blocks to remove\n    blocks_to_remove = {i: [] for i in range(self.dim + 1)}\n    for block in list_blocks:\n        if block.dim in self.complex_dict and block in self.complex_dict[block.dim]:\n            blocks_to_remove[block.dim].append(block)\n\n    # Find super-faces if needed\n    if include_upfaces:\n        for dimension in range(1, self.dim + 1):\n            for block in self.complex_dict[dimension]:\n                facets = block.get_all_facets()\n                if any(\n                    facet in blocks_to_remove[dimension - 1] for facet in facets\n                ):\n                    blocks_to_remove[dimension].append(block)\n\n    # Remove blocks\n    for dimension in blocks_to_remove:\n        for block in blocks_to_remove[dimension]:\n            if block in self.complex_dict[dimension]:\n                self.complex_dict[dimension].remove(block)\n\n    # Update complex_dict\n    for dimension in range(self.dim, -1, -1):\n        if len(self.complex_dict[dimension]) == 0:\n            del self.complex_dict[dimension]\n        else:\n            break\n\n    # Recompute dimension\n    self.dim = max(self.complex_dict, default=-1)\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration","title":"<code>Filtration</code>","text":"<p>Represents a lower-star filtration on a Letter Insertion Chain Complex C[W], for a set of words W with associated heights.</p> <p>It stores the blocks of the complex at each dimension with their corresponding heights. Provides methods for computing the Euler Characteristic Curve, persistent homology barcodes (with Z/Z2 coefficients), and a graphical representation of (accurate for low dimensions).</p> <p>One can access the k-th dimensional blocks by indexing the filtration as 'K[k]'. This returns a dictionary mapping each k-block to its height.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Maximum dimension of the filtration.</p> <code>filtration_dict</code> <code>dict</code> <p>Maps dimension d to a dictionary of blocks and their heights.</p> <code>filtration_values</code> <code>list</code> <p>Sorted list of heights used in the filtration.</p> Internal Attributes <p>_alphabet (Alphabet): Alphabet containing all symbols in W. _prod_symbol (str): Product symbol used for constructing blocks     ('*', '.', or '' for concatenation). _positions_dict (dict or None): Stores vertex positions for graph representations.</p> Notes <ul> <li>It initializes as an empty filtration. It can be made into the filtration of insertion chain     complexes of a set of words <code>W</code> by using the method <code>compute_d_skeleton(W, heights)</code>.</li> <li>Blocks can be added or removed by using the methods <code>add_blocks</code> and <code>remove_blocks</code>.</li> </ul> <p>Example:</p> <p>W = [\"ab\", \"aab\", \"abb\"] heights = [0.1, 0.3, 0.5] K = Filtration() # Creates an empty complex K.compute_d_skeleton(W, heights, max_dim=5) # makes K = a filtration of C[W] K[1]  # Access 1-dimensional blocks and their heights {a(1,a)b: 0.3, ab(1,b): 0.5}</p> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>class Filtration:\n    \"\"\"\n    Represents a lower-star filtration on a Letter Insertion Chain Complex C[W],\n    for a set of words W with associated heights.\n\n    It stores the blocks of the complex at each dimension with their corresponding heights.\n    Provides methods for computing the Euler Characteristic Curve,\n    persistent homology barcodes (with Z/Z2 coefficients),\n    and a graphical representation of (accurate for low dimensions).\n\n    One can access the k-th dimensional blocks by indexing the filtration as 'K[k]'.\n    This returns a dictionary mapping each k-block to its height.\n\n    Attributes:\n        dim (int): Maximum dimension of the filtration.\n        filtration_dict (dict): Maps dimension d to a dictionary of blocks and their heights.\n        filtration_values (list): Sorted list of heights used in the filtration.\n\n    Internal Attributes:\n        _alphabet (Alphabet): Alphabet containing all symbols in W.\n        _prod_symbol (str): Product symbol used for constructing blocks\n            ('*', '.', or '' for concatenation).\n        _positions_dict (dict or None): Stores vertex positions for graph representations.\n\n    Notes:\n        - It initializes as an empty filtration. It can be made into the filtration of insertion chain\n            complexes of a set of words `W` by using the method `compute_d_skeleton(W, heights)`.\n        - Blocks can be added or removed by using the methods `add_blocks` and `remove_blocks`.\n\n    Example:\n    &gt;&gt;&gt; W = [\"ab\", \"aab\", \"abb\"]\n    &gt;&gt;&gt; heights = [0.1, 0.3, 0.5]\n    &gt;&gt;&gt; K = Filtration() # Creates an empty complex\n    &gt;&gt;&gt; K.compute_d_skeleton(W, heights, max_dim=5) # makes K = a filtration of C[W]\n    &gt;&gt;&gt; K[1]  # Access 1-dimensional blocks and their heights\n    {a(1,a)b: 0.3, ab(1,b): 0.5}\n    \"\"\"\n\n    def __init__(self, alphabet=None, prod_symbol=None):\n        \"\"\"\n        Returns an empty Filtration object.\n\n        Args:\n            alphabet (Alphabet, optional): Alphabet object defining valid symbols.\n                If None, a new empty `Alphabet` is created.\n            prod_symbol (str, optional): The product symbol to use. Must be one of\n                {'', '*', '.'}. If None, it is inferred from the expression:\n                set to '*' if '*' appears, to '.' if '.' appears, or to '' (concatenation)\n                otherwise.\n        \"\"\"\n        # User inputs\n        self._alphabet = alphabet\n        self._prod_symbol = prod_symbol\n\n        # Filtration data\n        self.dim = -1\n        self.filtration_dict = {}\n        self.filtration_values = []\n\n        # Used when creating a graph\n        self._positions_dict = None\n\n    def _facets_maximal_word(self, word, indices, which=\"all\", casted=False):\n        \"\"\"\n        Generates the (upper/lower/all) facets of a block given as maximal word-indices pair.\n\n        Args:\n            w (str or SymPy expression): The maximal word, provided as a string if\n                `casted=False`, or as a processed (casted) word using the `cast_word`\n                method from `Alphabet`.\n            indices (list[int]): A list of indices that are converted into edges to construct a block.\n            which (str, optional): Which facets to produce, must be one of 'upper', 'lower',\n                or 'all'. Defaults to 'all'.\n            casted (bool, optional): Specifies whether the word has been pre-casted using\n                `Alphabet`. If False, it is treated as a string. Defaults to False.\n\n        Returns:\n            List[Block]: A list of facets.\n        \"\"\"\n\n        if not casted:\n            word = self._alphabet.cast_word(word)\n\n        factors = list(word.as_coeff_mul()[1])\n        upper_factors = []\n        lower_factors = []\n\n        length = len(factors)\n        for i in range(length):\n            base, exp = factors[i].as_base_exp()\n            if i in indices:\n                upper_factor = self._alphabet.get(str(base), 1)\n                if exp == 1:\n                    lower_factor = int(1)\n                else:\n                    lower_factor = base ** (exp - 1)\n\n                upper_factors.append(lower_factor * upper_factor)\n                if which in [\"all\", \"lower\"]:\n                    lower_factors.append(lower_factor)\n            else:\n                upper_factors.append(factors[i])\n                lower_factors.append(factors[i])\n\n        upper_facets = []\n        lower_facets = []\n        for i in indices:\n            if which in [\"all\", \"upper\"]:\n                block_exp = sym.prod(\n                    upper_factors[:i] + [factors[i]] + upper_factors[i + 1 :],\n                    start=int(1),\n                )\n                block = Block(str(block_exp), prod_symbol=\"*\", alphabet=self._alphabet)\n                # Fix prod_symbol pylint: disable=protected-access\n                block._prod_symbol = self._prod_symbol\n                upper_facets.append(block)\n            if which in [\"all\", \"lower\"]:\n                block_exp = sym.prod(\n                    upper_factors[:i] + [lower_factors[i]] + upper_factors[i + 1 :],\n                    start=int(1),\n                )\n                block = Block(str(block_exp), prod_symbol=\"*\", alphabet=self._alphabet)\n                lower_facets.append(block)\n                # Fix prod_symbol pylint: disable=protected-access\n                block._prod_symbol = self._prod_symbol\n\n        # Filter 0's in lower facets\n        if which in [\"all\", \"lower\"]:\n            while Block() in lower_facets:\n                lower_facets.remove(Block())\n\n        # Return the result\n        if which == \"upper\":\n            return upper_facets\n        if which == \"lower\":\n            return lower_facets\n        return upper_facets + lower_facets\n\n    def _block_maximal_word(self, word, indices, casted=False):\n        \"\"\"\n        Generates block based on the given maximal word and indices.\n\n        Args:\n            w (str or SymPy expression): The maximal word, provided as a string if `casted=False`,\n                or as a processed (casted) word using the `cast_word` method from `Alphabet`.\n            indices (list[int]): A list of indices that are converted into edges to construct a block.\n\n        Returns:\n            Block: The block represented by w(indices).\n        \"\"\"\n\n        if not casted:\n            word = self._alphabet.cast_word(word)\n\n        factors = list(word.as_coeff_mul()[1])\n        new_factors = []\n\n        length = len(factors)\n        for i in range(length):\n            base, exp = factors[i].as_base_exp()\n            if i in indices:\n                upper_factor = self._alphabet.get(str(base), 1)\n                if exp == 1:\n                    lower_factor = int(1)\n                else:\n                    lower_factor = base ** (exp - 1)\n\n                new_factors.append(lower_factor * upper_factor)\n            else:\n                new_factors.append(factors[i])\n\n        block_exp = sym.prod(new_factors, start=int(1))\n        block = Block(str(block_exp), prod_symbol=\"*\", alphabet=self._alphabet)\n        # Fix prod_symbol\n        block._prod_symbol = self._prod_symbol  # pylint: disable=protected-access\n        return block\n\n    def _lower_facets_maximal_word_as_pairs(self, word, indices, casted=False):\n        \"\"\"\n        Generates the lower facets of a block in word-indices representation,\n        as pairs of maximal word and indices.\n\n        Args:\n            w (str or SymPy expression: The maximal word, provided as a string if `casted=False`,\n                or as a processed (casted) word using the `cast_word` method from `Alphabet`.\n            indices (list[int]): A list of indices that are converted into edges to construct a block.\n            casted (bool, optional): Specifies whether the word has been pre-casted using `Alphabet`.\n                If False, the word is treated as a string. Defaults to False.\n\n        Returns:\n            Returns:\n                list[tuple[Expr, list[int]]]: List of pairs `(w, l)`, where `w` is a SymPy\n                expression, and `l` is a list of indices giving the word-indices\n                representation of the lower facets.\n        \"\"\"\n        if not casted:\n            word = self._alphabet.cast_word(word)\n\n        factors = list(word.as_coeff_mul()[1])\n        upper_factors = []\n        lower_factors = []\n\n        base_exp_pairs = [factor.as_base_exp() for factor in factors]\n        length = len(base_exp_pairs)\n\n        for i in range(length):\n            base = base_exp_pairs[i][0]\n            exp = base_exp_pairs[i][1]\n            if i in indices:\n                upper_factor = self._alphabet.get(str(base), 1)\n                if exp == 1:\n                    lower_factor = int(1)\n                else:\n                    lower_factor = base ** (exp - 1)\n\n                upper_factors.append(lower_factor * upper_factor)\n                lower_factors.append(lower_factor)\n            else:\n                upper_factors.append(factors[i])\n                lower_factors.append(factors[i])\n        lower_facets = []\n\n        for i in indices:\n            exp_i = base_exp_pairs[i][1]\n            if i == 0:\n                base_before = int(1)\n            else:\n                base_before = base_exp_pairs[i - 1][0]\n            if i + 1 &gt;= length:\n                base_after = int(1)\n            else:\n                base_after = base_exp_pairs[i + 1][0]\n            # Check if the resulting block is valid\n            if (\n                ((i - 1) in indices)\n                and ((i + 1) in indices)\n                and (exp_i) == 1\n                and (base_before == base_after)\n            ):\n                continue\n\n            # Compute maximal word\n            w_max = sym.prod(\n                factors[:i] + [lower_factors[i]] + factors[i + 1 :], start=int(1)\n            )\n\n            # Compute the new indices\n            new_indices = [\n                _compute_new_index_lower_facet(j, i, exp_i, base_before, base_after)\n                for j in indices\n                if i != j\n            ]\n\n            lower_facets.append((w_max, new_indices))\n\n        return lower_facets\n\n    def _check_edge(self, word1, word1_extended, word2_extended):\n        \"\"\"\n        Internal helper function used to check whether two vertices form a 1-block\n        and, if so, construct that 1-block. Assummes |word1|=|word2|+1.\n\n        Args:\n            word1 (SymPy expression or str): Base word corresponding to the first block.\n                It is assumed that |w_1| = |w_2| + 1.\n            word1_extended (list of tuple): List of (letter, exponent) pairs representing\n                the expanded form of `word1`.\n            word2_extended (list of tuple): List of (letter, exponent) pairs representing\n                the expanded form of the second word.\n\n        Returns:\n            tuple:\n                - bool: True if `word1` and `word2` are connected.\n                - Block or None: The corresponding 1-block, if an edge is found.\n                - int or None: The index `j` such that the pair (w_1, [j]) gives\n                  the 1-block in word\u2013indices form.\n        \"\"\"\n        word1_extended_extra = [\n            letter for letter, count in word1_extended for _ in range(count)\n        ]\n        word2_extended_extra = [\n            letter for letter, count in word2_extended for _ in range(count)\n        ]\n        i = 0\n        for j, pair in enumerate(word1_extended):\n            if (\n                word2_extended_extra\n                == word1_extended_extra[:i] + word1_extended_extra[i + 1 :]\n            ):\n                return True, self._block_maximal_word(word1, [j], True), j\n            i += pair[1]\n        return False, None, None\n\n    def _compute_one_skeleton(\n        self,\n        list_words,\n        list_heights,\n        already_blocks,\n        max_dim=1,\n        alphabet=None,\n        prod_symbol=None,\n        verbose=False,\n        check_duplicates=True,\n    ):\n        \"\"\"\n        This is an internal method used to initialize the filtration at dimensions 0 and 1.\n        The filtration and incidence dictionaries are updated in place.\n\n        Args:\n            list_words (list of str or Block objects): vertices for the filtration.\n            list_heights (list of int): heights associated to the words.\n            already_blocks (bool): If True, assumes the words are already block objects;\n                otherwise, they are converted to blocks.\n            max_dim (int or None): Maximum dimension to compute. Default is 1.\n            alphabet (Alphabet or None):  If None, uses `self._alphabet`.\n            prod_symbol (str or None): Symbol used for concatenation in word representations.\n            verbose (bool, optional): If True, prints progress messages. Default is False.\n            check_duplicates (bool, optional): If True, checks that all words are unique.\n                Defaults to True.\n        \"\"\"\n\n        if alphabet is None:\n            alphabet = self._alphabet\n        elif not isinstance(alphabet, Alphabet):\n            raise ValueError(\"alphabet must be a valid Alphabet object or None\")\n        elif isinstance(self._alphabet, Alphabet):\n            alphabet.update_letters(self._alphabet.letters_str)\n\n        if verbose:\n            print(\"Computing dimension 0 \\u2705\")\n        if already_blocks:\n            list_vertices = list_words\n            alphabet = _combine_blocks_alphabet(list_words, self._alphabet)\n        else:\n            list_vertices, alphabet, prod_symbol = _convert_words_to_blocks(\n                [str(w) for w in list_words],\n                prod_symbol=prod_symbol,\n                alphabet=self._alphabet,\n            )\n        self._alphabet = alphabet\n        self._prod_symbol = prod_symbol\n\n        # Check each word is provided only once\n        if check_duplicates:\n            if len(list_vertices) != len(set(list_vertices)):\n                raise ValueError(\"List of words has duplicated words\")\n        # Initialize Dictionary at dim=0\n        self.filtration_dict[0] = dict(zip(list_vertices, list_heights))\n\n        if max_dim == 0:\n            return\n\n        if verbose:\n            print(\"Computing dimension 1\", end=\"\")\n        # Computing Graph (dim=1)\n        self.filtration_dict[1] = dict()\n        self._incidence_dict[1] = dict()\n        list_vertices.sort(\n            key=lambda x: _expand_symp_word(x.get_expression())[1], reverse=True\n        )\n        list_expanded_vertices = [\n            _expand_symp_word(x.get_expression()) for x in list_vertices\n        ]\n        for i, word1 in enumerate(list_vertices):\n            word1_extended, word1_len = list_expanded_vertices[i]\n            for j in range(i + 1, len(list_vertices)):\n                word2 = list_vertices[j]\n                word2_extended, word2_len = list_expanded_vertices[j]\n                if word1_len - word2_len == 1:\n                    is_edge, block, block_index = self._check_edge(\n                        word1.get_expression(), word1_extended, word2_extended\n                    )\n                    if is_edge:\n                        self.filtration_dict[1][block] = max(\n                            self.filtration_dict[0][word1],\n                            self.filtration_dict[0][word2],\n                        )\n                        if word1.get_expression() in self._incidence_dict[1]:\n                            self._incidence_dict[1][word1.get_expression()].append(\n                                [block_index]\n                            )\n                        else:\n                            self._incidence_dict[1][word1.get_expression()] = [\n                                [block_index]\n                            ]\n                elif word1_len - word2_len &gt; 1:\n                    break\n        if len(self.filtration_dict[1]) == 0:\n            del self.filtration_dict[1]\n\n    def compute_d_skeleton(\n        self,\n        W,\n        heights=None,\n        max_dim=10,\n        alphabet=None,\n        prod_symbol=None,\n        check_duplicates=True,\n        already_blocks=False,\n        verbose=False,\n    ):\n        \"\"\"\n        Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W].\n        This method replaces any existing data in the Filtration with a new complex supported on `W`.\n\n        This method constructs all valid blocks up to the specified maximum dimension (`max_dim`)\n        for a given set of words `W` with associated heights. It begins by computing the\n        0- and 1-skeletons (vertices and edges), then iteratively extends to higher dimensions.\n\n        It updates the internal `filtration_dict` to the blocks supported on `W`.\n\n        Args:\n            W (list of str or Block): List of words (or blocks, if `already_blocks=True`)\n                forming the base of the complex.\n            heights (list of float, optional): Height values associated with each word.\n                If None, defaults to ones.\n            max_dim (int, optional): Maximum dimension of the skeleton to compute. Defaults to 10.\n            alphabet (Alphabet, optional): Alphabet object used together with the internal\n                `self._alphabet` and any letters inferred from `W`. If provided, its symbols\n                are merged with `self._alphabet`; otherwise, the new symbols are inferred entirely\n                from the given words.\n            prod_symbol (str, optional): Product symbol for block construction ('*', '.', or '').\n                If None, inferred automatically.\n            check_duplicates (bool, optional): Whether to verify that input words are unique.\n                Defaults to True.\n            already_blocks (bool, optional): If True, assumes the input `W` is already a list of\n                `Block` objects instead of strings. Defaults to False.\n            verbose (bool, optional): If True, prints progress information during computation.\n\n        Example:\n            &gt;&gt;&gt; W = ['a*b', 'a*b*b', 'a*a*b','']\n            &gt;&gt;&gt; K = Filtration()\n            &gt;&gt;&gt; K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2)\n            &gt;&gt;&gt; K[1]\n            {a*b*(1,b): 0.3, a*(1,a)*b: 0.2}\n        \"\"\"\n        if heights is None:\n            heights = [1] * len(W)\n        else:\n            if len(heights) != len(W):\n                raise ValueError(\n                    \"List of heighst must be same length as list of words, or None\"\n                )\n        self.filtration_values = list(set(heights))\n        self.filtration_values.sort()\n\n        # Restart dictionaries\n        self.filtration_dict = {}\n\n        # Used when computing the d-skeleton\n        self._incidence_dict = {}\n\n        # Compute one Skeleton\n        self._compute_one_skeleton(\n            W,\n            heights,\n            already_blocks,\n            max_dim,\n            alphabet,\n            prod_symbol,\n            verbose,\n            check_duplicates,\n        )\n\n        if max_dim == 1:\n            self.dim = max(self.filtration_dict)\n            return\n\n        dim = 2\n        while (dim &lt;= max_dim) and len(self._incidence_dict[dim - 1]) &gt; 0:\n            if verbose:\n                print(\" \\u2705\\nComputing dimension\", dim, end=\"\")\n\n            self._incidence_dict[dim] = dict()\n            for word in self._incidence_dict[dim - 1]:\n                indices = self._incidence_dict[dim - 1][word]\n                possible_indices = _candidate_indices_next(indices)\n\n                for k_indices in possible_indices:\n                    lower_facets_pairs = self._lower_facets_maximal_word_as_pairs(\n                        word, k_indices, True\n                    )\n\n                    # Check if lower_facets are all there\n                    all_facets_bool = True\n                    for w_max, indices_face in lower_facets_pairs:\n                        if (\n                            w_max in self._incidence_dict[dim - 1]\n                            and indices_face in self._incidence_dict[dim - 1][w_max]\n                        ):\n                            continue\n                        else:\n                            all_facets_bool = False\n                            break\n                    if all_facets_bool:\n                        # Add to incidence dictionary\n                        if word in self._incidence_dict[dim]:\n                            self._incidence_dict[dim][word].append(k_indices)\n                        else:\n                            self._incidence_dict[dim][word] = [k_indices]\n\n                        # Compute height of block and add\n                        facets = self._facets_maximal_word(\n                            word, k_indices, which=\"all\", casted=True\n                        )\n                        height = max(\n                            [self.filtration_dict[dim - 1][blk] for blk in facets]\n                        )\n\n                        block = self._block_maximal_word(word, k_indices, True)\n                        if dim in self.filtration_dict:\n                            self.filtration_dict[dim][block] = height\n                        else:\n                            self.filtration_dict[dim] = {block: height}\n            dim += 1\n        self.dim = max(self.filtration_dict)\n\n        if verbose:\n            print(\" \\u274C\")\n        del self._incidence_dict\n\n    def add_blocks(\n        self,\n        list_blocks,\n        list_heights=None,\n        prod_symbol=None,\n        already_blocks=False,\n        update_values=False,\n    ):\n        \"\"\"\n        Add new blocks to the Filtration.\n\n        Extends the current Filtration by inserting additional blocks and their faces.\n        This method allows dynamically modifying an existing filtration while ensuring,\n        as much as possible, that the result remains a valid filtration (i.e., if\n        \u03b1 \u2264 \u03b2, then F.get_complex(\u03b1) \u2286 F.get_complex(\u03b2)).\n\n        Intended for expert use only, since the resulting structure may not always be\n        a full Insertion Chain Complex C[W], but rather a subcomplex if some supporting\n        blocks are missing. The result may depend on the order in which the blocks are\n        provided.\n\n        The behavior depends on the value of ``update_values``:\n\n            - If ``update_values=True``, the heights of existing faces and super-faces\n              are updated as needed to maintain the filtration property. This ensures\n              that the new blocks can be inserted with the provided heights.\n\n            - If ``update_values=False`` (default), the method adds the blocks only if\n              their heights are consistent with the current filtration. Otherwise, the\n              maximum among the heights of their faces is used instead.\n\n\n        Args:\n            list_blocks (list[Block] or list[str]):\n                List of blocks to be added to the Filtration. If ``already_blocks`` is\n                False (default), the elements are assumed to be strings representing\n                blocks and will be converted. If True, they are assumed to be existing\n                ``Block`` objects.\n\n            list_heights (list[float] or float or None, optional):\n                Heights assigned to each block. If a single numeric value is provided,\n                it is used for all blocks. If None, all blocks receive height 1.\n\n            prod_symbol (str or None, optional):\n                Product symbol used in block representation (e.g., '*', '.', or\n                ''). If not specified, it is inferred from the input blocks.\n\n            already_blocks (bool, optional):\n                If True, elements of ``list_blocks`` are assumed to be valid ``Block``\n                objects. If False (default), the method attempts to convert the input\n                into blocks.\n\n            update_values (bool, optional):\n                If True, existing heights of faces and super-faces are updated as needed\n                to maintain consistency when inserting the new blocks. If False (default),\n                only new faces are added and the provided heights are applied when valid;\n                otherwise, the lowest consistent height is used instead.\n\n        Raises:\n            ValueError:\n                - If ``list_heights`` is a list whose length does not match ``list_blocks``.\n                - If ``list_heights`` is not a list, a numeric value, or None.\n                - If the height of a block is lower than the height of one of its faces\n                  already present in the filtration (when ``update_values=False``).\n\n        Notes:\n            - The internal alphabet and product symbol are updated to ensure consistency.\n            - The resulting filtration may vary depending on the order in which blocks\n              are inserted.\n            - Updating an existing filtration in this way may be more computationally\n              expensive than reconstructing a new Filtration directly from a set of words.\n        \"\"\"\n        # Convert into blocks if needed\n        if already_blocks:\n            alphabet = _combine_blocks_alphabet(list_blocks, self._alphabet)\n        else:\n            list_blocks, alphabet, prod_symbol = _convert_words_to_blocks(\n                list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n            )\n        self._alphabet = alphabet\n\n        # Uniformalize prod_symbols pylint: disable=protected-access\n        new_prods = [blk._prod_symbol for blk in list_blocks] + [self._prod_symbol]\n        if \"*\" in new_prods:\n            prod_symbol = \"*\"\n        elif \".\" in new_prods:\n            prod_symbol = \".\"\n        else:\n            prod_symbol = \"\"\n        self._prod_symbol = prod_symbol\n        for blk in list_blocks:\n            blk._prod_symbol = self._prod_symbol\n\n        if list_heights is None:\n            list_heights = [1] * len(list_blocks)\n        elif isinstance(list_heights, list):\n            # Check lengths agree\n            if len(list_blocks) != len(list_heights):\n                raise ValueError(\"list_heights must be same length as list_blocks\")\n        else:\n            try:\n                height = float(list_heights)\n                list_heights = [height] * len(list_blocks)\n            except BaseException:\n                raise ValueError(\n                    \"list_heights must be a list, a numeric value, or None\"\n                )\n\n        for block, height in zip(list_blocks, list_heights):\n            dim = block.dim\n\n            # Ensure a dictionary exists for this dimension\n            if dim not in self.filtration_dict:\n                self.filtration_dict[dim] = {}\n\n            # Add or update the main block\n            current_height = self.filtration_dict[dim].get(block)\n            if current_height is None or update_values:\n                self.filtration_dict[dim][block] = height\n\n            # Update or add all faces\n            for face in block.get_all_faces(include_self=False):\n                f_dim = face.dim\n                if f_dim not in self.filtration_dict:\n                    self.filtration_dict[f_dim] = {}\n\n                current_height = self.filtration_dict[f_dim].get(face)\n\n                if current_height is None:\n                    # New face \u2014 assign current block's height\n                    self.filtration_dict[f_dim][face] = height\n                elif update_values:\n                    # Keep the lowest (earliest) height to preserve filtration\n                    # order\n                    self.filtration_dict[f_dim][face] = min(current_height, height)\n\n        # Recompute dimension\n        self.dim = max(self.filtration_dict, default=-1)\n\n        # Fix values so the result is a filtration\n        for dim in range(1, self.dim + 1):\n            for block in self.filtration_dict[dim]:\n                facets = block.get_all_facets()\n                all_heights = [self.filtration_dict[dim][block]] + [\n                    self.filtration_dict[dim - 1][facet] for facet in facets\n                ]\n                new_height = max(all_heights)\n                self.filtration_dict[dim][block] = new_height\n\n        # Add filtration values\n        self.filtration_values += list_heights\n        self.filtration_values = list(set(self.filtration_values))\n        self.filtration_values.sort()\n\n    def remove_blocks(\n        self, list_blocks, prod_symbol=None, include_upfaces=True, already_blocks=False\n    ):\n        \"\"\"\n        Remove blocks from the Filtration.\n\n        Deletes specified blocks and optionally their super-faces from the Complex.\n        Intended for expert use only, since the resulting structure may not be a full\n        Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks\n        are missing.\n\n        Args:\n            list_blocks (list of Block or string): A list of blocks to remove. If\n                `already_blocks` is False (default), the elements are assumed to be strings\n                representing blocks and will be converted. If True, they are assumed to be\n                existing Block objects.\n            prod_symbol (str or None, optional): Product symbol used in block\n                representation ( '*', '.', or ''). If not specified, it is inferred\n                from the input blocks.\n            include_upfaces (bool, optional): If True, all super faces of the specified blocks\n                are also removed, so the result is a subcomplex. Default is True.\n            already_blocks (bool, optional): If True, the elements of `list_blocks`\n                are assumed to be valid Block objects. If False (default), the method\n                attempts to convert the input into blocks.\n        \"\"\"\n        # Make sure it is a list\n        if not isinstance(list_blocks, list):\n            raise TypeError(\"list_blocks must be a list\")\n\n        # Convert into blocks if needed\n        if not already_blocks:\n            list_blocks, _alphabet, prod_symbol = _convert_words_to_blocks(\n                list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n            )\n\n        # Dictionary of blocks to remove\n        blocks_to_remove = {i: [] for i in range(self.dim + 1)}\n        for block in list_blocks:\n            if (\n                block.dim in self.filtration_dict\n                and block in self.filtration_dict[block.dim]\n            ):\n                blocks_to_remove[block.dim].append(block)\n\n        # Find super-faces if needed\n        if include_upfaces:\n            for dimension in range(1, self.dim + 1):\n                for block in self.filtration_dict[dimension]:\n                    facets = block.get_all_facets()\n                    if any(\n                        facet in blocks_to_remove[dimension - 1] for facet in facets\n                    ):\n                        blocks_to_remove[dimension].append(block)\n\n        # Remove blocks\n        for dimension in blocks_to_remove:\n            for block in blocks_to_remove[dimension]:\n                if block in self.filtration_dict[dimension]:\n                    del self.filtration_dict[dimension][block]\n\n        # Update filtration_dict\n        for dimension in range(self.dim, -1, -1):\n            if len(self.filtration_dict[dimension]) == 0:\n                del self.filtration_dict[dimension]\n            else:\n                break\n\n        # Update filtration values\n        self.filtration_values = list(\n            {\n                val\n                for dimension_dict in self.filtration_dict.values()\n                for val in dimension_dict.values()\n            }\n        )\n        self.filtration_values.sort()\n\n        # Recompute dimension\n        self.dim = max(self.filtration_dict, default=-1)\n\n    def get_complex(self, height=None, max_dim=None):\n        \"\"\"\n        Constructs and returns a Complex object that includes all blocks\n        from the filtration whose height is less than or equal to the specified\n        value. The construction can also be limited to a specified maximum dimension.\n\n        Args:\n            height (float or int, optional): The maximum filtration value to include.\n                If None, the largest available filtration value is used.\n            max_dim (int, optional): The maximum dimension to include in the complex.\n                If None, the full dimension of the filtration is used.\n\n        Returns:\n            Complex: A Complex object containing all blocks up to the specified\n                height and dimension.\n        \"\"\"\n        from InDelsTopo.complex import (\n            Complex,\n        )  # pylint: disable=import-outside-toplevel\n\n        if height is None:\n            height = max(self.filtration_values, default=np.inf)\n        if max_dim is None:\n            max_dim = self.dim\n        max_dim = min(self.dim, max_dim)\n\n        complex_dict = {\n            dim: [\n                block\n                for block in self.filtration_dict[dim]\n                if self.filtration_dict[dim][block] &lt;= height\n            ]\n            for dim in range(max_dim + 1)\n        }\n        for dim in range(max_dim, -1, -1):\n            if len(complex_dict[dim]) == 0:\n                del complex_dict[dim]\n            else:\n                break\n        return Complex(\n            alphabet=self._alphabet,\n            prod_symbol=self._prod_symbol,\n            complex_dict=complex_dict,\n            height=height,\n        )\n\n    def get_euler_curve(self, x_values=None):\n        \"\"\"\n        This method evaluates the Euler characteristic of the complex at different\n        filtration heights and returns the resulting curve as paired x- and y-values.\n\n        Args:\n            x_values (list of float or int, optional): Filtration heights at which to\n                compute the Euler characteristic. If None, all existing filtration\n                values are used.\n\n        Returns:\n            tuple:\n                - list of float or int: Sorted filtration heights (x-values).\n                - list of int: Corresponding Euler characteristic values (y-values).\n        \"\"\"\n        if x_values is None:\n            x_values = self.filtration_values\n        x_values.sort()\n        y_values = [self.get_complex(h).euler_characteristic() for h in x_values]\n        return x_values, y_values\n\n    def get_persistent_homology_barcodes(\n        self, max_dim=None, inf_value=np.inf, get_height_indices=False\n    ):\n        \"\"\"\n        Compute persistent homology barcodes for the filtration using Z2 coefficients.\n\n        The method performs a lower-star filtration on the complex according to the\n        vertex heights and computes persistent homology up to the specified dimension.\n\n        Args:\n            max_dim (int, optional): Maximum dimension to compute accurately.\n                The skeleton of dimension up to max_dim+1 is used for this computation\n                if it was previously computed. If None or greater than the filtration's\n                dimension, all dimensions are included.\n            inf_value (float, optional): Value to assign to features that do not die\n                within the filtration. Defaults to infinity.\n            get_height_indices (bool, optional): If True, also return the indices\n                corresponding to the birth and death heights in the filtration. Defaults to False.\n\n        Returns:\n            dict or tuple:\n                - If `get_height_indices=False`: A dictionary mapping dimension `d`\n                  to a list of tuples `(birth, death)` representing persistent homology intervals.\n                - If `get_height_indices=True`: A tuple of two dictionaries:\n                    1. Barcodes as above.\n                    2. Corresponding indices of birth and death heights in `filtration_values`.\n\n        Notes:\n            The algorithm uses a boundary matrix over Z2 and reduces it following\n            the standard persistence algorithm (see arxiv:1506.08903).\n            Features that never die are assigned `inf_value` as their death time.\n        \"\"\"\n        # Import csc_matrix\n        from scipy.sparse import csc_matrix  # pylint: disable=import-outside-toplevel\n\n        if max_dim is None or max_dim &gt;= self.dim:\n            max_dim = self.dim\n            using_skeleton = False\n        elif max_dim == self.dim - 1:\n            max_dim = self.dim\n            using_skeleton = True\n        else:\n            max_dim += 1\n            using_skeleton = True\n\n        # Order the blocks according to their dimension and height\n        ordered_blocks = []\n        for dimension in range(max_dim + 1):\n            ordered_blocks += self[dimension]\n        ordered_blocks.sort(key=lambda blk: (self[blk.dim][blk], blk.dim))\n\n        ordered_blocks_dict = {ordered_blocks[i]: i for i in range(len(ordered_blocks))}\n        heights = [self[blk.dim][blk] for blk in ordered_blocks]\n\n        # Construct the boundary matrix\n        cols = []\n        rows = []\n        data = []\n        for id_col, blk in enumerate(ordered_blocks):\n            facets = blk.get_all_facets()\n            for facet in facets:\n                cols.append(id_col)\n                rows.append(ordered_blocks_dict[facet])\n                data.append(1)\n\n        N = len(ordered_blocks)\n        boundary_matrix = csc_matrix((data, (rows, cols)), shape=(N, N)).tolil()\n\n        # Perform row reduction (we follow the algorithm from\n        # https://arxiv.org/pdf/1506.08903)\n        low = []  # maps row index to pivot column index\n        barcodes = {}\n\n        if get_height_indices:\n            barcodes_indices = {}\n            height_indices = {\n                self.filtration_values[i]: i for i in range(len(self.filtration_values))\n            }\n\n        for j in range(N):\n            col = boundary_matrix.getcol(j)\n            if col.nnz &gt; 0:\n                # Set initial value for low(j)\n                low_j = col.nonzero()[0][-1]\n                while low_j in low:\n                    i = low.index(low_j)\n                    # add column i to column j\n                    col = col + boundary_matrix.getcol(i)\n                    col.data = col.data % 2  # Make adition modulo 2\n                    col.eliminate_zeros()\n                    if col.nnz &gt; 0:\n                        low_j = col.nonzero()[0][-1]  # update low_j value\n                    else:\n                        low_j = -1\n                        break\n                boundary_matrix[:, j] = col  # update column j in the matrix\n                low.append(low_j)  # Save value for low_j\n            else:\n                # Set -1, for undefined low(j)\n                low.append(-1)\n\n        # Extract (birth, death) pairs\n        for j, low_j in enumerate(low):\n            if low_j &gt;= 0:\n                birth = heights[low_j]\n                death = heights[j]\n                if death &gt; birth:\n                    dim = ordered_blocks[low_j].dim\n                    if dim not in barcodes:\n                        barcodes[dim] = []\n                        if get_height_indices:\n                            barcodes_indices[dim] = []\n                    barcodes[dim].append((birth, death))\n                    if get_height_indices:\n                        barcodes_indices[dim].append(\n                            (height_indices[birth], height_indices[death])\n                        )\n            elif j not in low:\n                birth = heights[j]\n                dim = ordered_blocks[j].dim\n                if dim not in barcodes:\n                    barcodes[dim] = []\n                    if get_height_indices:\n                        barcodes_indices[dim] = []\n                barcodes[dim].append((birth, inf_value))\n                if get_height_indices:\n                    barcodes_indices[dim].append((height_indices[birth], np.inf))\n\n        if using_skeleton:\n            if max_dim in barcodes:\n                del barcodes[max_dim]\n                if get_height_indices:\n                    del barcodes_indices[max_dim]\n\n        if get_height_indices:\n            return barcodes, barcodes_indices\n        return barcodes\n\n    def get_graph(\n        self,\n        height=None,\n        height_id=None,\n        show_labels=True,\n        max_dim=5,\n        positions=None,\n        initial_positions=None,\n        fixed=None,\n        recompute=False,\n        colors_by_dim=None,\n        ax=None,\n    ):\n        \"\"\"\n        Generate a graphical representation of the filtration up to a specified dimension.\n\n        Positions of vertices can be computed automatically or provided manually.\n        Only accurate for low-dimensional complexes (typically dim &lt;= 3).\n\n        Args:\n            height (float, optional): Maximum height value for including blocks in the graph.\n                Defaults to the maximum filtration value.\n            height_id (int, optional): Index into the sorted list of filtration values.\n                Used if `height` is None. Defaults to None.\n            show_labels (bool, optional): Whether to display labels on the vertices. Defaults to True.\n            max_dim (int, optional): Maximum dimension of blocks to include in the graph. Defaults to 5.\n            positions (dict, optional): Dictionary of vertex positions.\n                If None, positions are computed automatically. Once computed, they are reused\n                everytime this method is called, unless recompute is set to True.\n            initial_positions (dict, optional): Initial positions used to seed the\n                automatic layout algorithm.\n            fixed (list or None, optional): List of vertex keys to fix in place when computing positions.\n                Defaults to None.\n            recompute (bool, optional): Whether to recompute vertex positions even\n                if already stored. Defaults to False.\n            colors_by_dim (list of str, optional): List of colors to use for each dimension.\n                If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].\n            ax (matplotlib.axes._subplots.Axes3DSubplot, optional): A Matplotlib Axes\n                object to draw the plot on. If None, a new figure and axes are created.\n                Defaults to None.\n\n        Returns:\n            matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.\n        \"\"\"\n        if self.dim == -1:\n            return None\n        if (positions is None) or recompute:\n            if (self._positions_dict is None) or recompute:\n                self._positions_dict = graphics.compute_vertex_positions(\n                    self, pos0=initial_positions, fixed=fixed\n                )\n            # Make sure position includes all vertices\n            elif any(vertex not in self._positions_dict for vertex in self[0]):\n                # Update with pos0\n                if isinstance(initial_positions, dict):\n                    for vertex in initial_positions:\n                        self._positions_dict[vertex] = initial_positions[vertex]\n                # Compute for all vertices\n                self._positions_dict = graphics.compute_vertex_positions(\n                    self,\n                    pos0=self._positions_dict,\n                    fixed=list(self._positions_dict.keys()),\n                )\n\n            # Get the positions\n            positions = self._positions_dict\n\n        if height is None:\n            try:\n                height = self.filtration_values[height_id]\n            except BaseException:\n                height = max(self.filtration_values, default=np.inf)\n\n        ax = graphics.make_graph(\n            self,\n            pos=positions,\n            show_labels=show_labels,\n            max_dim=max_dim,\n            height=height,\n            already_complex=False,\n            colors_by_dim=colors_by_dim,\n            ax=ax,\n        )\n\n        return ax\n\n    def __str__(self):\n        to_print = \"Filtration of Insertion Chain Complexes: \\n\"\n        to_print += \"alphabet: \" + str(self._alphabet) + \".\\n\"\n        try:\n            filtration_values_range = (\n                \"[\"\n                + str(self.filtration_values[0])\n                + \",\"\n                + str(self.filtration_values[-1])\n                + \"]\"\n            )\n        except BaseException:\n            filtration_values_range = \"[]\"\n        to_print += \"heights in: \" + filtration_values_range + \".\\n\"\n        to_print += \"dimension: \" + str(self.dim) + \".\\n\"\n        to_print += \"vertices: \" + str(len(self[0])) + \".\\n\"\n        to_print += (\n            \"blocks: \" + str(sum([len(self[k]) for k in range(self.dim + 1)])) + \".\"\n        )\n        return to_print\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __getitem__(self, key):\n        if 0 &lt;= key &lt;= self.dim:\n            return self.filtration_dict[key]\n        return {}\n\n    def get_alphabet(self):\n        \"\"\"Returns the alphabet attribute.\"\"\"\n        return self._alphabet\n\n    def get_block_height(self, block, already_block=False):\n        \"\"\"\n        Returns the height of the block in the filtration or None if it is not in the filtration.\n\n        Args:\n            block (Block or string): A block to check its height. If `already_blocks` is False (default),\n            it is assumed to be a string representing the block. If True, it is assumed to be an\n                existing Block object.\n            already_block (bool, optional): If True, `block`\n                is assumed to be a valid Block object. If False (default), the method\n                attempts to convert the input into a block.\n        \"\"\"\n        # Convert into blocks if needed\n        if not already_block:\n            block = Block(block, prod_symbol=self._prod_symbol, alphabet=self._alphabet)\n\n        dim = block.dim\n        if block in self[dim]:\n            return self[dim][block]\n        return None\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.__init__","title":"<code>__init__(alphabet=None, prod_symbol=None)</code>","text":"<p>Returns an empty Filtration object.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object defining valid symbols. If None, a new empty <code>Alphabet</code> is created.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>The product symbol to use. Must be one of {'', '', '.'}. If None, it is inferred from the expression: set to '' if '*' appears, to '.' if '.' appears, or to '' (concatenation) otherwise.</p> <code>None</code> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def __init__(self, alphabet=None, prod_symbol=None):\n    \"\"\"\n    Returns an empty Filtration object.\n\n    Args:\n        alphabet (Alphabet, optional): Alphabet object defining valid symbols.\n            If None, a new empty `Alphabet` is created.\n        prod_symbol (str, optional): The product symbol to use. Must be one of\n            {'', '*', '.'}. If None, it is inferred from the expression:\n            set to '*' if '*' appears, to '.' if '.' appears, or to '' (concatenation)\n            otherwise.\n    \"\"\"\n    # User inputs\n    self._alphabet = alphabet\n    self._prod_symbol = prod_symbol\n\n    # Filtration data\n    self.dim = -1\n    self.filtration_dict = {}\n    self.filtration_values = []\n\n    # Used when creating a graph\n    self._positions_dict = None\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.add_blocks","title":"<code>add_blocks(list_blocks, list_heights=None, prod_symbol=None, already_blocks=False, update_values=False)</code>","text":"<p>Add new blocks to the Filtration.</p> <p>Extends the current Filtration by inserting additional blocks and their faces. This method allows dynamically modifying an existing filtration while ensuring, as much as possible, that the result remains a valid filtration (i.e., if \u03b1 \u2264 \u03b2, then F.get_complex(\u03b1) \u2286 F.get_complex(\u03b2)).</p> <p>Intended for expert use only, since the resulting structure may not always be a full Insertion Chain Complex C[W], but rather a subcomplex if some supporting blocks are missing. The result may depend on the order in which the blocks are provided.</p> <p>The behavior depends on the value of <code>update_values</code>:</p> <pre><code>- If ``update_values=True``, the heights of existing faces and super-faces\n  are updated as needed to maintain the filtration property. This ensures\n  that the new blocks can be inserted with the provided heights.\n\n- If ``update_values=False`` (default), the method adds the blocks only if\n  their heights are consistent with the current filtration. Otherwise, the\n  maximum among the heights of their faces is used instead.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list[Block] or list[str]</code> <p>List of blocks to be added to the Filtration. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing <code>Block</code> objects.</p> required <code>list_heights</code> <code>list[float] or float or None</code> <p>Heights assigned to each block. If a single numeric value is provided, it is used for all blocks. If None, all blocks receive height 1.</p> <code>None</code> <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation (e.g., '*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>already_blocks</code> <code>bool</code> <p>If True, elements of <code>list_blocks</code> are assumed to be valid <code>Block</code> objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code> <code>update_values</code> <code>bool</code> <p>If True, existing heights of faces and super-faces are updated as needed to maintain consistency when inserting the new blocks. If False (default), only new faces are added and the provided heights are applied when valid; otherwise, the lowest consistent height is used instead.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If <code>list_heights</code> is a list whose length does not match <code>list_blocks</code>.</li> <li>If <code>list_heights</code> is not a list, a numeric value, or None.</li> <li>If the height of a block is lower than the height of one of its faces   already present in the filtration (when <code>update_values=False</code>).</li> </ul> Notes <ul> <li>The internal alphabet and product symbol are updated to ensure consistency.</li> <li>The resulting filtration may vary depending on the order in which blocks   are inserted.</li> <li>Updating an existing filtration in this way may be more computationally   expensive than reconstructing a new Filtration directly from a set of words.</li> </ul> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def add_blocks(\n    self,\n    list_blocks,\n    list_heights=None,\n    prod_symbol=None,\n    already_blocks=False,\n    update_values=False,\n):\n    \"\"\"\n    Add new blocks to the Filtration.\n\n    Extends the current Filtration by inserting additional blocks and their faces.\n    This method allows dynamically modifying an existing filtration while ensuring,\n    as much as possible, that the result remains a valid filtration (i.e., if\n    \u03b1 \u2264 \u03b2, then F.get_complex(\u03b1) \u2286 F.get_complex(\u03b2)).\n\n    Intended for expert use only, since the resulting structure may not always be\n    a full Insertion Chain Complex C[W], but rather a subcomplex if some supporting\n    blocks are missing. The result may depend on the order in which the blocks are\n    provided.\n\n    The behavior depends on the value of ``update_values``:\n\n        - If ``update_values=True``, the heights of existing faces and super-faces\n          are updated as needed to maintain the filtration property. This ensures\n          that the new blocks can be inserted with the provided heights.\n\n        - If ``update_values=False`` (default), the method adds the blocks only if\n          their heights are consistent with the current filtration. Otherwise, the\n          maximum among the heights of their faces is used instead.\n\n\n    Args:\n        list_blocks (list[Block] or list[str]):\n            List of blocks to be added to the Filtration. If ``already_blocks`` is\n            False (default), the elements are assumed to be strings representing\n            blocks and will be converted. If True, they are assumed to be existing\n            ``Block`` objects.\n\n        list_heights (list[float] or float or None, optional):\n            Heights assigned to each block. If a single numeric value is provided,\n            it is used for all blocks. If None, all blocks receive height 1.\n\n        prod_symbol (str or None, optional):\n            Product symbol used in block representation (e.g., '*', '.', or\n            ''). If not specified, it is inferred from the input blocks.\n\n        already_blocks (bool, optional):\n            If True, elements of ``list_blocks`` are assumed to be valid ``Block``\n            objects. If False (default), the method attempts to convert the input\n            into blocks.\n\n        update_values (bool, optional):\n            If True, existing heights of faces and super-faces are updated as needed\n            to maintain consistency when inserting the new blocks. If False (default),\n            only new faces are added and the provided heights are applied when valid;\n            otherwise, the lowest consistent height is used instead.\n\n    Raises:\n        ValueError:\n            - If ``list_heights`` is a list whose length does not match ``list_blocks``.\n            - If ``list_heights`` is not a list, a numeric value, or None.\n            - If the height of a block is lower than the height of one of its faces\n              already present in the filtration (when ``update_values=False``).\n\n    Notes:\n        - The internal alphabet and product symbol are updated to ensure consistency.\n        - The resulting filtration may vary depending on the order in which blocks\n          are inserted.\n        - Updating an existing filtration in this way may be more computationally\n          expensive than reconstructing a new Filtration directly from a set of words.\n    \"\"\"\n    # Convert into blocks if needed\n    if already_blocks:\n        alphabet = _combine_blocks_alphabet(list_blocks, self._alphabet)\n    else:\n        list_blocks, alphabet, prod_symbol = _convert_words_to_blocks(\n            list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n        )\n    self._alphabet = alphabet\n\n    # Uniformalize prod_symbols pylint: disable=protected-access\n    new_prods = [blk._prod_symbol for blk in list_blocks] + [self._prod_symbol]\n    if \"*\" in new_prods:\n        prod_symbol = \"*\"\n    elif \".\" in new_prods:\n        prod_symbol = \".\"\n    else:\n        prod_symbol = \"\"\n    self._prod_symbol = prod_symbol\n    for blk in list_blocks:\n        blk._prod_symbol = self._prod_symbol\n\n    if list_heights is None:\n        list_heights = [1] * len(list_blocks)\n    elif isinstance(list_heights, list):\n        # Check lengths agree\n        if len(list_blocks) != len(list_heights):\n            raise ValueError(\"list_heights must be same length as list_blocks\")\n    else:\n        try:\n            height = float(list_heights)\n            list_heights = [height] * len(list_blocks)\n        except BaseException:\n            raise ValueError(\n                \"list_heights must be a list, a numeric value, or None\"\n            )\n\n    for block, height in zip(list_blocks, list_heights):\n        dim = block.dim\n\n        # Ensure a dictionary exists for this dimension\n        if dim not in self.filtration_dict:\n            self.filtration_dict[dim] = {}\n\n        # Add or update the main block\n        current_height = self.filtration_dict[dim].get(block)\n        if current_height is None or update_values:\n            self.filtration_dict[dim][block] = height\n\n        # Update or add all faces\n        for face in block.get_all_faces(include_self=False):\n            f_dim = face.dim\n            if f_dim not in self.filtration_dict:\n                self.filtration_dict[f_dim] = {}\n\n            current_height = self.filtration_dict[f_dim].get(face)\n\n            if current_height is None:\n                # New face \u2014 assign current block's height\n                self.filtration_dict[f_dim][face] = height\n            elif update_values:\n                # Keep the lowest (earliest) height to preserve filtration\n                # order\n                self.filtration_dict[f_dim][face] = min(current_height, height)\n\n    # Recompute dimension\n    self.dim = max(self.filtration_dict, default=-1)\n\n    # Fix values so the result is a filtration\n    for dim in range(1, self.dim + 1):\n        for block in self.filtration_dict[dim]:\n            facets = block.get_all_facets()\n            all_heights = [self.filtration_dict[dim][block]] + [\n                self.filtration_dict[dim - 1][facet] for facet in facets\n            ]\n            new_height = max(all_heights)\n            self.filtration_dict[dim][block] = new_height\n\n    # Add filtration values\n    self.filtration_values += list_heights\n    self.filtration_values = list(set(self.filtration_values))\n    self.filtration_values.sort()\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.compute_d_skeleton","title":"<code>compute_d_skeleton(W, heights=None, max_dim=10, alphabet=None, prod_symbol=None, check_duplicates=True, already_blocks=False, verbose=False)</code>","text":"<p>Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W]. This method replaces any existing data in the Filtration with a new complex supported on <code>W</code>.</p> <p>This method constructs all valid blocks up to the specified maximum dimension (<code>max_dim</code>) for a given set of words <code>W</code> with associated heights. It begins by computing the 0- and 1-skeletons (vertices and edges), then iteratively extends to higher dimensions.</p> <p>It updates the internal <code>filtration_dict</code> to the blocks supported on <code>W</code>.</p> <p>Parameters:</p> Name Type Description Default <code>W</code> <code>list of str or Block</code> <p>List of words (or blocks, if <code>already_blocks=True</code>) forming the base of the complex.</p> required <code>heights</code> <code>list of float</code> <p>Height values associated with each word. If None, defaults to ones.</p> <code>None</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of the skeleton to compute. Defaults to 10.</p> <code>10</code> <code>alphabet</code> <code>Alphabet</code> <p>Alphabet object used together with the internal <code>self._alphabet</code> and any letters inferred from <code>W</code>. If provided, its symbols are merged with <code>self._alphabet</code>; otherwise, the new symbols are inferred entirely from the given words.</p> <code>None</code> <code>prod_symbol</code> <code>str</code> <p>Product symbol for block construction ('*', '.', or ''). If None, inferred automatically.</p> <code>None</code> <code>check_duplicates</code> <code>bool</code> <p>Whether to verify that input words are unique. Defaults to True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, assumes the input <code>W</code> is already a list of <code>Block</code> objects instead of strings. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints progress information during computation.</p> <code>False</code> Example <p>W = ['ab', 'abb', 'aab',''] K = Filtration() K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2) K[1] {ab(1,b): 0.3, a(1,a)*b: 0.2}</p> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def compute_d_skeleton(\n    self,\n    W,\n    heights=None,\n    max_dim=10,\n    alphabet=None,\n    prod_symbol=None,\n    check_duplicates=True,\n    already_blocks=False,\n    verbose=False,\n):\n    \"\"\"\n    Compute the d-skeleton of the Insertion Chain Complex generated by a set of words, C[W].\n    This method replaces any existing data in the Filtration with a new complex supported on `W`.\n\n    This method constructs all valid blocks up to the specified maximum dimension (`max_dim`)\n    for a given set of words `W` with associated heights. It begins by computing the\n    0- and 1-skeletons (vertices and edges), then iteratively extends to higher dimensions.\n\n    It updates the internal `filtration_dict` to the blocks supported on `W`.\n\n    Args:\n        W (list of str or Block): List of words (or blocks, if `already_blocks=True`)\n            forming the base of the complex.\n        heights (list of float, optional): Height values associated with each word.\n            If None, defaults to ones.\n        max_dim (int, optional): Maximum dimension of the skeleton to compute. Defaults to 10.\n        alphabet (Alphabet, optional): Alphabet object used together with the internal\n            `self._alphabet` and any letters inferred from `W`. If provided, its symbols\n            are merged with `self._alphabet`; otherwise, the new symbols are inferred entirely\n            from the given words.\n        prod_symbol (str, optional): Product symbol for block construction ('*', '.', or '').\n            If None, inferred automatically.\n        check_duplicates (bool, optional): Whether to verify that input words are unique.\n            Defaults to True.\n        already_blocks (bool, optional): If True, assumes the input `W` is already a list of\n            `Block` objects instead of strings. Defaults to False.\n        verbose (bool, optional): If True, prints progress information during computation.\n\n    Example:\n        &gt;&gt;&gt; W = ['a*b', 'a*b*b', 'a*a*b','']\n        &gt;&gt;&gt; K = Filtration()\n        &gt;&gt;&gt; K.compute_d_skeleton(W, heights=[0.1, 0.3, 0.2,0.4], max_dim=2)\n        &gt;&gt;&gt; K[1]\n        {a*b*(1,b): 0.3, a*(1,a)*b: 0.2}\n    \"\"\"\n    if heights is None:\n        heights = [1] * len(W)\n    else:\n        if len(heights) != len(W):\n            raise ValueError(\n                \"List of heighst must be same length as list of words, or None\"\n            )\n    self.filtration_values = list(set(heights))\n    self.filtration_values.sort()\n\n    # Restart dictionaries\n    self.filtration_dict = {}\n\n    # Used when computing the d-skeleton\n    self._incidence_dict = {}\n\n    # Compute one Skeleton\n    self._compute_one_skeleton(\n        W,\n        heights,\n        already_blocks,\n        max_dim,\n        alphabet,\n        prod_symbol,\n        verbose,\n        check_duplicates,\n    )\n\n    if max_dim == 1:\n        self.dim = max(self.filtration_dict)\n        return\n\n    dim = 2\n    while (dim &lt;= max_dim) and len(self._incidence_dict[dim - 1]) &gt; 0:\n        if verbose:\n            print(\" \\u2705\\nComputing dimension\", dim, end=\"\")\n\n        self._incidence_dict[dim] = dict()\n        for word in self._incidence_dict[dim - 1]:\n            indices = self._incidence_dict[dim - 1][word]\n            possible_indices = _candidate_indices_next(indices)\n\n            for k_indices in possible_indices:\n                lower_facets_pairs = self._lower_facets_maximal_word_as_pairs(\n                    word, k_indices, True\n                )\n\n                # Check if lower_facets are all there\n                all_facets_bool = True\n                for w_max, indices_face in lower_facets_pairs:\n                    if (\n                        w_max in self._incidence_dict[dim - 1]\n                        and indices_face in self._incidence_dict[dim - 1][w_max]\n                    ):\n                        continue\n                    else:\n                        all_facets_bool = False\n                        break\n                if all_facets_bool:\n                    # Add to incidence dictionary\n                    if word in self._incidence_dict[dim]:\n                        self._incidence_dict[dim][word].append(k_indices)\n                    else:\n                        self._incidence_dict[dim][word] = [k_indices]\n\n                    # Compute height of block and add\n                    facets = self._facets_maximal_word(\n                        word, k_indices, which=\"all\", casted=True\n                    )\n                    height = max(\n                        [self.filtration_dict[dim - 1][blk] for blk in facets]\n                    )\n\n                    block = self._block_maximal_word(word, k_indices, True)\n                    if dim in self.filtration_dict:\n                        self.filtration_dict[dim][block] = height\n                    else:\n                        self.filtration_dict[dim] = {block: height}\n        dim += 1\n    self.dim = max(self.filtration_dict)\n\n    if verbose:\n        print(\" \\u274C\")\n    del self._incidence_dict\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.get_alphabet","title":"<code>get_alphabet()</code>","text":"<p>Returns the alphabet attribute.</p> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def get_alphabet(self):\n    \"\"\"Returns the alphabet attribute.\"\"\"\n    return self._alphabet\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.get_block_height","title":"<code>get_block_height(block, already_block=False)</code>","text":"<p>Returns the height of the block in the filtration or None if it is not in the filtration.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block or string</code> <p>A block to check its height. If <code>already_blocks</code> is False (default),</p> required <code>already_block</code> <code>bool</code> <p>If True, <code>block</code> is assumed to be a valid Block object. If False (default), the method attempts to convert the input into a block.</p> <code>False</code> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def get_block_height(self, block, already_block=False):\n    \"\"\"\n    Returns the height of the block in the filtration or None if it is not in the filtration.\n\n    Args:\n        block (Block or string): A block to check its height. If `already_blocks` is False (default),\n        it is assumed to be a string representing the block. If True, it is assumed to be an\n            existing Block object.\n        already_block (bool, optional): If True, `block`\n            is assumed to be a valid Block object. If False (default), the method\n            attempts to convert the input into a block.\n    \"\"\"\n    # Convert into blocks if needed\n    if not already_block:\n        block = Block(block, prod_symbol=self._prod_symbol, alphabet=self._alphabet)\n\n    dim = block.dim\n    if block in self[dim]:\n        return self[dim][block]\n    return None\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.get_complex","title":"<code>get_complex(height=None, max_dim=None)</code>","text":"<p>Constructs and returns a Complex object that includes all blocks from the filtration whose height is less than or equal to the specified value. The construction can also be limited to a specified maximum dimension.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>float or int</code> <p>The maximum filtration value to include. If None, the largest available filtration value is used.</p> <code>None</code> <code>max_dim</code> <code>int</code> <p>The maximum dimension to include in the complex. If None, the full dimension of the filtration is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Complex</code> <p>A Complex object containing all blocks up to the specified height and dimension.</p> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def get_complex(self, height=None, max_dim=None):\n    \"\"\"\n    Constructs and returns a Complex object that includes all blocks\n    from the filtration whose height is less than or equal to the specified\n    value. The construction can also be limited to a specified maximum dimension.\n\n    Args:\n        height (float or int, optional): The maximum filtration value to include.\n            If None, the largest available filtration value is used.\n        max_dim (int, optional): The maximum dimension to include in the complex.\n            If None, the full dimension of the filtration is used.\n\n    Returns:\n        Complex: A Complex object containing all blocks up to the specified\n            height and dimension.\n    \"\"\"\n    from InDelsTopo.complex import (\n        Complex,\n    )  # pylint: disable=import-outside-toplevel\n\n    if height is None:\n        height = max(self.filtration_values, default=np.inf)\n    if max_dim is None:\n        max_dim = self.dim\n    max_dim = min(self.dim, max_dim)\n\n    complex_dict = {\n        dim: [\n            block\n            for block in self.filtration_dict[dim]\n            if self.filtration_dict[dim][block] &lt;= height\n        ]\n        for dim in range(max_dim + 1)\n    }\n    for dim in range(max_dim, -1, -1):\n        if len(complex_dict[dim]) == 0:\n            del complex_dict[dim]\n        else:\n            break\n    return Complex(\n        alphabet=self._alphabet,\n        prod_symbol=self._prod_symbol,\n        complex_dict=complex_dict,\n        height=height,\n    )\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.get_euler_curve","title":"<code>get_euler_curve(x_values=None)</code>","text":"<p>This method evaluates the Euler characteristic of the complex at different filtration heights and returns the resulting curve as paired x- and y-values.</p> <p>Parameters:</p> Name Type Description Default <code>x_values</code> <code>list of float or int</code> <p>Filtration heights at which to compute the Euler characteristic. If None, all existing filtration values are used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <ul> <li>list of float or int: Sorted filtration heights (x-values).</li> <li>list of int: Corresponding Euler characteristic values (y-values).</li> </ul> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def get_euler_curve(self, x_values=None):\n    \"\"\"\n    This method evaluates the Euler characteristic of the complex at different\n    filtration heights and returns the resulting curve as paired x- and y-values.\n\n    Args:\n        x_values (list of float or int, optional): Filtration heights at which to\n            compute the Euler characteristic. If None, all existing filtration\n            values are used.\n\n    Returns:\n        tuple:\n            - list of float or int: Sorted filtration heights (x-values).\n            - list of int: Corresponding Euler characteristic values (y-values).\n    \"\"\"\n    if x_values is None:\n        x_values = self.filtration_values\n    x_values.sort()\n    y_values = [self.get_complex(h).euler_characteristic() for h in x_values]\n    return x_values, y_values\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.get_graph","title":"<code>get_graph(height=None, height_id=None, show_labels=True, max_dim=5, positions=None, initial_positions=None, fixed=None, recompute=False, colors_by_dim=None, ax=None)</code>","text":"<p>Generate a graphical representation of the filtration up to a specified dimension.</p> <p>Positions of vertices can be computed automatically or provided manually. Only accurate for low-dimensional complexes (typically dim &lt;= 3).</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>float</code> <p>Maximum height value for including blocks in the graph. Defaults to the maximum filtration value.</p> <code>None</code> <code>height_id</code> <code>int</code> <p>Index into the sorted list of filtration values. Used if <code>height</code> is None. Defaults to None.</p> <code>None</code> <code>show_labels</code> <code>bool</code> <p>Whether to display labels on the vertices. Defaults to True.</p> <code>True</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension of blocks to include in the graph. Defaults to 5.</p> <code>5</code> <code>positions</code> <code>dict</code> <p>Dictionary of vertex positions. If None, positions are computed automatically. Once computed, they are reused everytime this method is called, unless recompute is set to True.</p> <code>None</code> <code>initial_positions</code> <code>dict</code> <p>Initial positions used to seed the automatic layout algorithm.</p> <code>None</code> <code>fixed</code> <code>list or None</code> <p>List of vertex keys to fix in place when computing positions. Defaults to None.</p> <code>None</code> <code>recompute</code> <code>bool</code> <p>Whether to recompute vertex positions even if already stored. Defaults to False.</p> <code>False</code> <code>colors_by_dim</code> <code>list of str</code> <p>List of colors to use for each dimension. If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].</p> <code>None</code> <code>ax</code> <code>Axes3DSubplot</code> <p>A Matplotlib Axes object to draw the plot on. If None, a new figure and axes are created. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.</p> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def get_graph(\n    self,\n    height=None,\n    height_id=None,\n    show_labels=True,\n    max_dim=5,\n    positions=None,\n    initial_positions=None,\n    fixed=None,\n    recompute=False,\n    colors_by_dim=None,\n    ax=None,\n):\n    \"\"\"\n    Generate a graphical representation of the filtration up to a specified dimension.\n\n    Positions of vertices can be computed automatically or provided manually.\n    Only accurate for low-dimensional complexes (typically dim &lt;= 3).\n\n    Args:\n        height (float, optional): Maximum height value for including blocks in the graph.\n            Defaults to the maximum filtration value.\n        height_id (int, optional): Index into the sorted list of filtration values.\n            Used if `height` is None. Defaults to None.\n        show_labels (bool, optional): Whether to display labels on the vertices. Defaults to True.\n        max_dim (int, optional): Maximum dimension of blocks to include in the graph. Defaults to 5.\n        positions (dict, optional): Dictionary of vertex positions.\n            If None, positions are computed automatically. Once computed, they are reused\n            everytime this method is called, unless recompute is set to True.\n        initial_positions (dict, optional): Initial positions used to seed the\n            automatic layout algorithm.\n        fixed (list or None, optional): List of vertex keys to fix in place when computing positions.\n            Defaults to None.\n        recompute (bool, optional): Whether to recompute vertex positions even\n            if already stored. Defaults to False.\n        colors_by_dim (list of str, optional): List of colors to use for each dimension.\n            If None, defaults to ['black', 'gray', 'yellow', 'red', 'blue', 'purple'].\n        ax (matplotlib.axes._subplots.Axes3DSubplot, optional): A Matplotlib Axes\n            object to draw the plot on. If None, a new figure and axes are created.\n            Defaults to None.\n\n    Returns:\n        matplotlib.axes.Axes: Matplotlib axes object containing the drawn graph.\n    \"\"\"\n    if self.dim == -1:\n        return None\n    if (positions is None) or recompute:\n        if (self._positions_dict is None) or recompute:\n            self._positions_dict = graphics.compute_vertex_positions(\n                self, pos0=initial_positions, fixed=fixed\n            )\n        # Make sure position includes all vertices\n        elif any(vertex not in self._positions_dict for vertex in self[0]):\n            # Update with pos0\n            if isinstance(initial_positions, dict):\n                for vertex in initial_positions:\n                    self._positions_dict[vertex] = initial_positions[vertex]\n            # Compute for all vertices\n            self._positions_dict = graphics.compute_vertex_positions(\n                self,\n                pos0=self._positions_dict,\n                fixed=list(self._positions_dict.keys()),\n            )\n\n        # Get the positions\n        positions = self._positions_dict\n\n    if height is None:\n        try:\n            height = self.filtration_values[height_id]\n        except BaseException:\n            height = max(self.filtration_values, default=np.inf)\n\n    ax = graphics.make_graph(\n        self,\n        pos=positions,\n        show_labels=show_labels,\n        max_dim=max_dim,\n        height=height,\n        already_complex=False,\n        colors_by_dim=colors_by_dim,\n        ax=ax,\n    )\n\n    return ax\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.get_persistent_homology_barcodes","title":"<code>get_persistent_homology_barcodes(max_dim=None, inf_value=np.inf, get_height_indices=False)</code>","text":"<p>Compute persistent homology barcodes for the filtration using Z2 coefficients.</p> <p>The method performs a lower-star filtration on the complex according to the vertex heights and computes persistent homology up to the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>max_dim</code> <code>int</code> <p>Maximum dimension to compute accurately. The skeleton of dimension up to max_dim+1 is used for this computation if it was previously computed. If None or greater than the filtration's dimension, all dimensions are included.</p> <code>None</code> <code>inf_value</code> <code>float</code> <p>Value to assign to features that do not die within the filtration. Defaults to infinity.</p> <code>inf</code> <code>get_height_indices</code> <code>bool</code> <p>If True, also return the indices corresponding to the birth and death heights in the filtration. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>dict or tuple: - If <code>get_height_indices=False</code>: A dictionary mapping dimension <code>d</code>   to a list of tuples <code>(birth, death)</code> representing persistent homology intervals. - If <code>get_height_indices=True</code>: A tuple of two dictionaries:     1. Barcodes as above.     2. Corresponding indices of birth and death heights in <code>filtration_values</code>.</p> Notes <p>The algorithm uses a boundary matrix over Z2 and reduces it following the standard persistence algorithm (see arxiv:1506.08903). Features that never die are assigned <code>inf_value</code> as their death time.</p> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def get_persistent_homology_barcodes(\n    self, max_dim=None, inf_value=np.inf, get_height_indices=False\n):\n    \"\"\"\n    Compute persistent homology barcodes for the filtration using Z2 coefficients.\n\n    The method performs a lower-star filtration on the complex according to the\n    vertex heights and computes persistent homology up to the specified dimension.\n\n    Args:\n        max_dim (int, optional): Maximum dimension to compute accurately.\n            The skeleton of dimension up to max_dim+1 is used for this computation\n            if it was previously computed. If None or greater than the filtration's\n            dimension, all dimensions are included.\n        inf_value (float, optional): Value to assign to features that do not die\n            within the filtration. Defaults to infinity.\n        get_height_indices (bool, optional): If True, also return the indices\n            corresponding to the birth and death heights in the filtration. Defaults to False.\n\n    Returns:\n        dict or tuple:\n            - If `get_height_indices=False`: A dictionary mapping dimension `d`\n              to a list of tuples `(birth, death)` representing persistent homology intervals.\n            - If `get_height_indices=True`: A tuple of two dictionaries:\n                1. Barcodes as above.\n                2. Corresponding indices of birth and death heights in `filtration_values`.\n\n    Notes:\n        The algorithm uses a boundary matrix over Z2 and reduces it following\n        the standard persistence algorithm (see arxiv:1506.08903).\n        Features that never die are assigned `inf_value` as their death time.\n    \"\"\"\n    # Import csc_matrix\n    from scipy.sparse import csc_matrix  # pylint: disable=import-outside-toplevel\n\n    if max_dim is None or max_dim &gt;= self.dim:\n        max_dim = self.dim\n        using_skeleton = False\n    elif max_dim == self.dim - 1:\n        max_dim = self.dim\n        using_skeleton = True\n    else:\n        max_dim += 1\n        using_skeleton = True\n\n    # Order the blocks according to their dimension and height\n    ordered_blocks = []\n    for dimension in range(max_dim + 1):\n        ordered_blocks += self[dimension]\n    ordered_blocks.sort(key=lambda blk: (self[blk.dim][blk], blk.dim))\n\n    ordered_blocks_dict = {ordered_blocks[i]: i for i in range(len(ordered_blocks))}\n    heights = [self[blk.dim][blk] for blk in ordered_blocks]\n\n    # Construct the boundary matrix\n    cols = []\n    rows = []\n    data = []\n    for id_col, blk in enumerate(ordered_blocks):\n        facets = blk.get_all_facets()\n        for facet in facets:\n            cols.append(id_col)\n            rows.append(ordered_blocks_dict[facet])\n            data.append(1)\n\n    N = len(ordered_blocks)\n    boundary_matrix = csc_matrix((data, (rows, cols)), shape=(N, N)).tolil()\n\n    # Perform row reduction (we follow the algorithm from\n    # https://arxiv.org/pdf/1506.08903)\n    low = []  # maps row index to pivot column index\n    barcodes = {}\n\n    if get_height_indices:\n        barcodes_indices = {}\n        height_indices = {\n            self.filtration_values[i]: i for i in range(len(self.filtration_values))\n        }\n\n    for j in range(N):\n        col = boundary_matrix.getcol(j)\n        if col.nnz &gt; 0:\n            # Set initial value for low(j)\n            low_j = col.nonzero()[0][-1]\n            while low_j in low:\n                i = low.index(low_j)\n                # add column i to column j\n                col = col + boundary_matrix.getcol(i)\n                col.data = col.data % 2  # Make adition modulo 2\n                col.eliminate_zeros()\n                if col.nnz &gt; 0:\n                    low_j = col.nonzero()[0][-1]  # update low_j value\n                else:\n                    low_j = -1\n                    break\n            boundary_matrix[:, j] = col  # update column j in the matrix\n            low.append(low_j)  # Save value for low_j\n        else:\n            # Set -1, for undefined low(j)\n            low.append(-1)\n\n    # Extract (birth, death) pairs\n    for j, low_j in enumerate(low):\n        if low_j &gt;= 0:\n            birth = heights[low_j]\n            death = heights[j]\n            if death &gt; birth:\n                dim = ordered_blocks[low_j].dim\n                if dim not in barcodes:\n                    barcodes[dim] = []\n                    if get_height_indices:\n                        barcodes_indices[dim] = []\n                barcodes[dim].append((birth, death))\n                if get_height_indices:\n                    barcodes_indices[dim].append(\n                        (height_indices[birth], height_indices[death])\n                    )\n        elif j not in low:\n            birth = heights[j]\n            dim = ordered_blocks[j].dim\n            if dim not in barcodes:\n                barcodes[dim] = []\n                if get_height_indices:\n                    barcodes_indices[dim] = []\n            barcodes[dim].append((birth, inf_value))\n            if get_height_indices:\n                barcodes_indices[dim].append((height_indices[birth], np.inf))\n\n    if using_skeleton:\n        if max_dim in barcodes:\n            del barcodes[max_dim]\n            if get_height_indices:\n                del barcodes_indices[max_dim]\n\n    if get_height_indices:\n        return barcodes, barcodes_indices\n    return barcodes\n</code></pre>"},{"location":"reference/#InDelsTopo.Filtration.remove_blocks","title":"<code>remove_blocks(list_blocks, prod_symbol=None, include_upfaces=True, already_blocks=False)</code>","text":"<p>Remove blocks from the Filtration.</p> <p>Deletes specified blocks and optionally their super-faces from the Complex. Intended for expert use only, since the resulting structure may not be a full Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks are missing.</p> <p>Parameters:</p> Name Type Description Default <code>list_blocks</code> <code>list of Block or string</code> <p>A list of blocks to remove. If <code>already_blocks</code> is False (default), the elements are assumed to be strings representing blocks and will be converted. If True, they are assumed to be existing Block objects.</p> required <code>prod_symbol</code> <code>str or None</code> <p>Product symbol used in block representation ( '*', '.', or ''). If not specified, it is inferred from the input blocks.</p> <code>None</code> <code>include_upfaces</code> <code>bool</code> <p>If True, all super faces of the specified blocks are also removed, so the result is a subcomplex. Default is True.</p> <code>True</code> <code>already_blocks</code> <code>bool</code> <p>If True, the elements of <code>list_blocks</code> are assumed to be valid Block objects. If False (default), the method attempts to convert the input into blocks.</p> <code>False</code> Source code in <code>InDelsTopo/filtration.py</code> <pre><code>def remove_blocks(\n    self, list_blocks, prod_symbol=None, include_upfaces=True, already_blocks=False\n):\n    \"\"\"\n    Remove blocks from the Filtration.\n\n    Deletes specified blocks and optionally their super-faces from the Complex.\n    Intended for expert use only, since the resulting structure may not be a full\n    Insertion Chain Complex C[W], but rather a subcomplex if some supported blocks\n    are missing.\n\n    Args:\n        list_blocks (list of Block or string): A list of blocks to remove. If\n            `already_blocks` is False (default), the elements are assumed to be strings\n            representing blocks and will be converted. If True, they are assumed to be\n            existing Block objects.\n        prod_symbol (str or None, optional): Product symbol used in block\n            representation ( '*', '.', or ''). If not specified, it is inferred\n            from the input blocks.\n        include_upfaces (bool, optional): If True, all super faces of the specified blocks\n            are also removed, so the result is a subcomplex. Default is True.\n        already_blocks (bool, optional): If True, the elements of `list_blocks`\n            are assumed to be valid Block objects. If False (default), the method\n            attempts to convert the input into blocks.\n    \"\"\"\n    # Make sure it is a list\n    if not isinstance(list_blocks, list):\n        raise TypeError(\"list_blocks must be a list\")\n\n    # Convert into blocks if needed\n    if not already_blocks:\n        list_blocks, _alphabet, prod_symbol = _convert_words_to_blocks(\n            list_blocks, prod_symbol=prod_symbol, alphabet=self._alphabet\n        )\n\n    # Dictionary of blocks to remove\n    blocks_to_remove = {i: [] for i in range(self.dim + 1)}\n    for block in list_blocks:\n        if (\n            block.dim in self.filtration_dict\n            and block in self.filtration_dict[block.dim]\n        ):\n            blocks_to_remove[block.dim].append(block)\n\n    # Find super-faces if needed\n    if include_upfaces:\n        for dimension in range(1, self.dim + 1):\n            for block in self.filtration_dict[dimension]:\n                facets = block.get_all_facets()\n                if any(\n                    facet in blocks_to_remove[dimension - 1] for facet in facets\n                ):\n                    blocks_to_remove[dimension].append(block)\n\n    # Remove blocks\n    for dimension in blocks_to_remove:\n        for block in blocks_to_remove[dimension]:\n            if block in self.filtration_dict[dimension]:\n                del self.filtration_dict[dimension][block]\n\n    # Update filtration_dict\n    for dimension in range(self.dim, -1, -1):\n        if len(self.filtration_dict[dimension]) == 0:\n            del self.filtration_dict[dimension]\n        else:\n            break\n\n    # Update filtration values\n    self.filtration_values = list(\n        {\n            val\n            for dimension_dict in self.filtration_dict.values()\n            for val in dimension_dict.values()\n        }\n    )\n    self.filtration_values.sort()\n\n    # Recompute dimension\n    self.dim = max(self.filtration_dict, default=-1)\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#tutorial","title":"Tutorial","text":"<p>A Jupyter notebook tutorial is provided in <code>tutorials/</code>.</p>"}]}